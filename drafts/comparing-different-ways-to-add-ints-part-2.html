<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Comparing different ways to add ints (part 2) // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Comparing different ways to add ints (part 2)</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/python.html">python</a>
                        </p>
                </header>
            </section>
            <h2>Background</h2>
<p>As outlined in part 1, we are comparing recursive and iterative solutions to a simple problem. As seen in the chart, there is a sudden jump in execution times of the recursive function, when the length of array becomes ~900 ints. Using the <code>cProfile</code> and <code>line_profile</code> modules in python, I will be investigating what caused this increase in execution times. cProfile collects information what each script on a high-level. line_profile allows us to examine each method call in more detail.</p>
<h3>Helper methods</h3>
<p>The script from part 1 had to be changed to profile the relevant function calls and save the results. This effectively wraps the function calls with cProfiler and then saves the results into a .dmp type. Afterwards results are plotted.</p>
<h3>Profile run</h3>
<p>Profile run method instantiates 2 <code>cProfile.Profile()</code> classes for iterative and recursive solution profiling. Looping over different array lengths, the iter_sum and recus_sum solutions are profiled. The profiling information is saved to disk using the <code>dump_stats()</code> method, which takes a string for argument name. </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">profile_run</span><span class="p">(</span><span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cProfile</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
    <span class="n">iter_arr_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">recur_arr_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">iter_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">recur_times</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">arr_length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)]</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)]</span>

        <span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
        <span class="n">pr2</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
        <span class="c"># good test case, because there will be a carry bit over every step</span>
        <span class="n">pr</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
        <span class="n">res_iter</span><span class="p">,</span> <span class="n">time_iter</span> <span class="o">=</span> <span class="n">iter_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
        <span class="n">pr</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
        <span class="n">pr</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s">&quot;iter_{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)))</span>
        <span class="n">iter_arr_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)</span>
        <span class="n">iter_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_iter</span><span class="p">)</span>

        <span class="n">pr2</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
        <span class="n">res_recur</span><span class="p">,</span> <span class="n">time_recur</span> <span class="o">=</span> <span class="n">recur_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
        <span class="n">pr2</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
        <span class="n">pr2</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s">&quot;recur_{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)))</span>
        <span class="n">recur_arr_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)</span>
        <span class="n">recur_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_recur</span><span class="p">)</span>

    <span class="n">plot_results_for_cprofile</span><span class="p">([</span><span class="n">iter_arr_lengths</span><span class="p">,</span> <span class="n">recur_arr_lengths</span><span class="p">],</span>
                              <span class="p">[</span><span class="n">iter_times</span><span class="p">,</span> <span class="n">recur_times</span><span class="p">],</span> <span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">)</span>
</pre></div>


<h4>dump_stats()</h4>
<p>Used the length of input arrays as id of this profiler run. Looking at the source for cProfile.Profile.dump_stats()</p>
<div class="highlight"><pre>    <span class="k">def</span> <span class="nf">dump_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">marshal</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_stats</span><span class="p">()</span>
        <span class="n">marshal</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>We see that it uses the marshal module. From the <a href="https://docs.python.org/3/library/marshal.html">documentation</a>, we know that:</p>
<ul>
<li>
<p>Details of the format are undocumented on purpose; it may change between Python versions (although it rarely does).</p>
</li>
<li>
<p>This is not a general "persistence" module. For general persistence and transfer of Python objects through RPC calls, see the modules :mod:<code>pickle</code> and :mod:<code>shelve</code>. The :mod:<code>marshal</code> module exists mainly to support reading and writing the "pseudo-compiled" code for Python modules of :file:<code>.pyc</code> files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you're serializing and de-serializing Python objects, use the :mod:<code>pickle</code> module instead -- the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal.</p>
</li>
<li>
<p>The :mod:<code>marshal</code> module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.</p>
</li>
</ul>
<p>What joy! This uses a badly documented, backwards-incompatible, insecure module with incomplete support for Python types.  </p>
<h3>Plot results</h3>
<p>The <code>plot_results</code> method will also change. Instead of using a scatter plot, we will be drawing lines, which will make it easier to see the increase in gradient. It also takes the right and left limits to the x values (lengths of the array). Setting xlim to the plot will help us focus the picture. Small changes include not marking the last points in recursive times (we will avoid stack overflow). </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">plot_results_for_cprofile</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Size of input arrays&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Time to calculate sum (ms)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Comparing iterative vs recursive sum methods&#39;</span><span class="p">)</span>

    <span class="n">iter_arr_lengths</span><span class="p">,</span> <span class="n">recur_arr_lengths</span> <span class="o">=</span> <span class="n">xs</span>
    <span class="n">iters</span><span class="p">,</span> <span class="n">recurs</span> <span class="o">=</span> <span class="n">ys</span>

    <span class="c"># plot iterative times</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iter_arr_lengths</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iters</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s">&quot;red&quot;</span><span class="p">)</span>

    <span class="c"># plot recursive times</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recur_arr_lengths</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recurs</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s">&quot;green&quot;</span><span class="p">)</span>
    <span class="c"># last point in recursive times is before stack overflow</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;sum_ints_plot.png&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">1200</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Saved plot as {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
</pre></div>


<h2>Results</h2>
<h3>Plot</h3>
<p><img alt="Photo" src="/drafts/images/plot_sum_ints_profiler.png" /></p>
<p>In the graph, green is still recursive, red is iterative times. There are several notables differences - times are higher overall. Each of them takes ~1 second longer, but the difference between iterative and recursive is still present. There is a huge spike for the recursive solution when the input arrays are of size 907. This makes it easy to investigate function calls.</p>
<h3>Reading the dump</h3>
<p>A read_dump.py is defined to print the dump to terminal</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">pstats</span>
<span class="kn">import</span> <span class="nn">marshal</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Supply a filename&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">stats</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>


<p>Using this script, we examine the dumps of recursive calls with arrays of lengths 906 and 907 (before the peak and the peak itself).</p>
<div class="highlight"><pre><span class="nv">$$$$</span> ./read_dump.py recur_906
Mon Jul <span class="m">17</span> 01:22:36 <span class="m">2017</span>    recur_906

         <span class="m">5446</span> <span class="k">function</span> calls <span class="o">(</span><span class="m">4540</span> primitive calls<span class="o">)</span> in 0.002 seconds

   Ordered by: <span class="k">function</span> name

   ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>
      <span class="m">906</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method divmod<span class="o">}</span>
     <span class="m">2720</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method len<span class="o">}</span>
        <span class="m">2</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method <span class="nb">time</span><span class="o">}</span>
      <span class="m">907</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;append&#39;</span> of <span class="s1">&#39;list&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;disable&#39;</span> of <span class="s1">&#39;_lsprof.Profiler&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;format&#39;</span> of <span class="s1">&#39;str&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.002    0.002 sum_ints_as_arrays.py:24<span class="o">(</span>newfunc<span class="o">)</span>
        <span class="m">1</span>    0.000    0.000    0.002    0.002 sum_ints_as_arrays.py:87<span class="o">(</span>recur_sum<span class="o">)</span>
    907/1    0.002    0.000    0.002    0.002 sum_ints_as_arrays.py:63<span class="o">(</span>recur_sum_helper<span class="o">)</span>


<span class="nv">$$$$</span> ./read_dump.py recur_907
Mon Jul <span class="m">17</span> 01:22:36 <span class="m">2017</span>    recur_907

         <span class="m">5452</span> <span class="k">function</span> calls <span class="o">(</span><span class="m">4545</span> primitive calls<span class="o">)</span> in 0.014 seconds

   Ordered by: <span class="k">function</span> name

   ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>
      <span class="m">907</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method divmod<span class="o">}</span>
     <span class="m">2723</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method len<span class="o">}</span>
        <span class="m">2</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method <span class="nb">time</span><span class="o">}</span>
      <span class="m">908</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;append&#39;</span> of <span class="s1">&#39;list&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;disable&#39;</span> of <span class="s1">&#39;_lsprof.Profiler&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.000    0.000 <span class="o">{</span>method <span class="s1">&#39;format&#39;</span> of <span class="s1">&#39;str&#39;</span> objects<span class="o">}</span>
        <span class="m">1</span>    0.000    0.000    0.014    0.014 sum_ints_as_arrays.py:24<span class="o">(</span>newfunc<span class="o">)</span>
        <span class="m">1</span>    0.000    0.000    0.014    0.014 sum_ints_as_arrays.py:87<span class="o">(</span>recur_sum<span class="o">)</span>
    908/1    0.014    0.000    0.014    0.014 sum_ints_as_arrays.py:63<span class="o">(</span>recur_sum_helper<span class="o">)</span>
</pre></div>


<p>The increase in execution times seems to depend on recur_sum_helper(). Between recur_906 and recur_907, recur_sum_helper now takes 7x as much time as it did before. </p>
<p>We will need to use line_profiling to get more detail about the increase in execution times. </p>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>