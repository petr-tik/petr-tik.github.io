<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Stracing emacs // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Stracing emacs</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/linux.html">linux</a>
                                <a class="post-category" href="/tag/tracing.html">tracing</a>
                                <a class="post-category" href="/tag/emacs.html">emacs</a>
                        </p>
                </header>
            </section>
            <p>This post is about learning strace by examining the start up of emacs. I ran the command below, waited until emacs was fully loaded and quit it. -C combines -c with normal output i.e. it printed each syscall, while the process was live and finished the file with the summary table. Mine is not a vanilla version of emacs, which might make it different (TODO: compare vanilla emacs to mine) - <a href="https://github.com/petr-tik/emacs-config">my .emacs can be found</a>. For each syscall I investigate and summarise errorcodes and their frequency.</p>
<div class="highlight"><pre>strace -C -o emacs_strace_output emacs
</pre></div>


<h2>Format</h2>
<p>I will choose different parameters by which I will choose syscalls to analyse. Then I use the manpage, my favourite search engine (CrouchCrouchWalk) to write up my understanding of the processes.</p>
<h2>Top 10 by time</h2>
<p>From the <code>man strace | grep -A 4 sort</code> page - Strace can sort by time, calls, name, and nothing (default is time). For data consistency, I will use the same output file and use small python scripts to recalculate other sorting factors (below).</p>
<div class="highlight"><pre>% <span class="nb">time     </span>seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 27.05    0.000109           <span class="m">0</span>     <span class="m">18973</span>     <span class="m">17979</span> open
 23.33    0.000094           <span class="m">0</span>      <span class="m">5192</span>      <span class="m">3609</span> recvmsg
 15.88    0.000064           <span class="m">0</span>      <span class="m">2432</span>           munmap
 13.65    0.000055           <span class="m">0</span>      <span class="m">3179</span>           poll
  8.44    0.000034           <span class="m">0</span>      <span class="m">3208</span>         <span class="m">1</span> <span class="nb">read</span>
<span class="nb">  </span>6.45    0.000026           <span class="m">0</span>      <span class="m">1610</span>           writev
  2.73    0.000011           <span class="m">0</span>      <span class="m">5127</span>           lseek
  2.48    0.000010           <span class="m">0</span>      <span class="m">1005</span>           close
  0.00    0.000000           <span class="m">0</span>        <span class="m">14</span>           write
  0.00    0.000000           <span class="m">0</span>       <span class="m">605</span>       <span class="m">119</span> stat
</pre></div>


<h3>open</h3>
<p>Syscall that usually takes a pointer to const array of chars for pathname and an int for flags. Flags carry information about access modes (read-only, write-only or read-n-write) and file status flags. </p>
<p>Returns an int that is a file descriptor (non-negative int), which other syscalls in the process will use to access the same file. There is no need to randomly assign fd numbers, so they are given out in ascending order. </p>
<p>Errors: </p>
<p>Used the magic of grep and awk to extract, count and summarise the number of times each return value (including errors) occured.</p>
<div class="highlight"><pre>grep <span class="s2">&quot;open&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;)&quot; } { print $2 }&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
</pre></div>


<p><code>grep "open(" emacs_strace_output</code></p>
<p>Should be obvious. Returns the lines with open syscall trace. "open(" guarantees </p>
<div class="highlight"><pre>awk &#39;BEGIN { FS=&quot;)&quot;} { print $2 }&#39;
</pre></div>


<p>Takes the lines and prints column 2 and onwards after the ")" separator, which comes at the end of the open syscall. This should be reusable. Output format is different between errors and normal return values.</p>
<div class="highlight"><pre> <span class="o">=</span> -1 ENOENT <span class="o">(</span>No such file or <span class="nv">directory</span>
 <span class="o">=</span> <span class="nv">8</span>
 <span class="o">=</span> 8
</pre></div>


<p>so we use another awk to print the 2 column, which will be the return value. In the case of open, we only need that. Successful return is a positive int file descriptor, a negative return value can be looked up in the man page for open. Sorting arranges values return values in order, so <code>uniq -c</code> can summarise and return the count of each value followed by the value. <code>sort -nr</code> sorts it by numeric value in descending order of counts. </p>
<div class="highlight"><pre>petr_tik@merluza:~/Coding/my-gh-page<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;count   ret_val&quot;</span><span class="p">;</span> grep <span class="s2">&quot;^open(&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;)&quot; } { print $2 }&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
count   ret_val
  <span class="m">17979</span> -1
    <span class="m">624</span> 7
    <span class="m">131</span> 8
     <span class="m">86</span> 3
     <span class="m">83</span> 9
     <span class="m">20</span> 6
     <span class="m">15</span> 4
     <span class="m">11</span> 11
     <span class="m">10</span> 5
      <span class="m">6</span> 10
      <span class="m">5</span> 14
      <span class="m">2</span> 12
      <span class="m">1</span> 13
</pre></div>


<p>As seen in the overall summary, 17979 open syscalls returned the error value -1, which stands for ENOINT - no such file or directory. Judging by the greatest return value, not more than 14 file descriptors are assigned at once during the start-up process. 18973 - 17979 = 994 and there are 1005 succesful <code>close</code> syscalls, so 11 times an fd must have been closed and reused. </p>
<p>Looking at each open syscall with return value 7. </p>
<div class="highlight"><pre><span class="nv">$$$ </span>grep <span class="s2">&quot;^open&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;\&quot;| &quot; } { print $2,$6 }&#39;</span> <span class="p">|</span> grep <span class="s2">&quot; 7&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
     <span class="m">23</span> /usr/share/icons/default/index.theme
     <span class="m">12</span> /home/petr_tik/.emacs.d/elpa/dash-20161121.55/dash-autoloads.el
      <span class="m">8</span> /home/petr_tik/.emacs.d/elpa/s-20140714.707/s-autoloads.el
      <span class="m">6</span> /usr/share/emacs/24.5/lisp/emacs-lisp/cl-seq.elc
      <span class="m">6</span> /home/petr_tik/.emacs.d/elpa/json-snatcher-20150511.2047/json-snatcher-autoloads.el
      <span class="m">6</span> /home/petr_tik/.emacs.d/elpa/json-reformat-20160212.53/json-reformat-autoloads.el
      ...
      more filespaths
</pre></div>


<p>shows that several files are repeatedly opened on the same file descriptor. </p>
<p>Looking at the usr/share/icons/default/index.theme</p>
<div class="highlight"><pre>petr_tik@merluza:~/Coding/my-gh-page<span class="nv">$ </span>grep -n <span class="s2">&quot;usr/share/icons/default/index.theme&quot;</span> emacs_strace_output 
1530:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 6
3412:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 7
3446:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 7
    ...
    more filespaths
</pre></div>


<p>we take the line numbers where /usr/share/icons/default/index.theme appears and examine a typical case of such a syscall. The first line it is opened under fd 6, so we take the needed number of lines (head for first 1549 lines, outof which we will need the last 20). </p>
<div class="highlight"><pre><span class="nv">$$$ </span>head -n <span class="m">1549</span> emacs_strace_output <span class="p">|</span> tail -n -20 
open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 6
fstat<span class="o">(</span>6, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0644, <span class="nv">st_size</span><span class="o">=</span>32, ...<span class="o">})</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 4096, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_ANONYMOUS, -1, 0<span class="o">)</span> <span class="o">=</span> 0x7f24722d7000
<span class="nb">read</span><span class="o">(</span>6, <span class="s2">&quot;[Icon Theme]\nInherits=DMZ-White\n&quot;</span>, 4096<span class="o">)</span> <span class="o">=</span> 32
close<span class="o">(</span>6<span class="o">)</span>                                <span class="o">=</span> 0
</pre></div>


<h3>recvmsg</h3>
<p>syscall to receive messages from a socket. Came from 4.4BSD (sockets were a BSD invention)
Input is a socket file descriptor int, pointer to the struct of type msghdr and int for flags. If succesful, they return the length of the receied message. </p>
<p>recvmsg uses the pointer to the msghdr struct to minimise the number of arguments. </p>
<p>Errors:</p>
<h3>munmap</h3>
<p>Evil brother of mmap (more info below), which deletes the mappings for the specified address. After that, all references to addresses in that range (addr + length) are invalidated. NB - closing a file descriptor doesn't unmap the region, which means for security you want to close fds and then unmap the region. </p>
<p>Input:
    pointer of type void to address 
    size_t length</p>
<p>Returns:
    0 if succesful
    -1 on failure</p>
<p>mmap - takes more parameters like flags and protection flags, which determine the access rights to those pages. </p>
<h3>poll</h3>
<p>Similar to select syscall, only newer. ppoll is newer still. Waits for one of a set of fds to come available for IO operations. </p>
<p>Input:
    pointer to struct of type pollfd - carries the filedescriptor int and requested events
    nfds_t - number of file descriptors to watch
    timeout - milliseconds the syscall can block while waiting for an fd to be ready. It can be interrupted by a signal hanlder. You can set an infinite timeout with a negative value.</p>
<p>Returns:
    if succesful - positive number of structurs with several returned event fields. 
    0 if timed out and/or no fds became ready
    -1 on error</p>
<h3>read</h3>
<p>Tries to read bytes from a given file descriptor into a buffer. </p>
<p>Gotcha: if count &gt; SSIZE_MAX, the result is unspecified.</p>
<p>Input:
    file descriptor 
    pointer to buf
    count of type size_t </p>
<p>Returns:
    if successfully read - returns int number of read bytes, by which the file position is also advanced. The return value may be less than the count (bytes that were requested to read), if a signal interrupts the syscall or we reach EOF. 
    on error, -1 is set to errno. Unspecified if the file position value changes. </p>
<h3>writev</h3>
<p>Writes given buffers of data to a given file descriptor. Similar to write, but sequentially goes through all the buffers. </p>
<p>Returns:
    number of bytes written.
    -1 if error</p>
<h3>lseek</h3>
<p>Given a file descritpor, offset and whence parameters, reposition the offset on the file descriptor. It can move the offset beyond the file size. </p>
<p>Returns: resulting offset location (in bytes) from the beginning of the file.</p>
<h3>close</h3>
<p>Does what it says on the tin. Closes a given file desciptor, which allows the int value to be reused. It can return an error and you better check the return value to avoid nasty bugs. It can be interrupted by a signal, in which case it doesn't close the file. Prone to race conditions.</p>
<h3>write</h3>
<p>writes to a given file descriptor.</p>
<h3>stat</h3>
<p>Like the terminal stat command, returns the status of a file at a given pathname.</p>
<h2>getting summaries</h2>
<div class="highlight"><pre>grep open emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;{ print $5 }&#39;</span>
</pre></div>


<h2>Top 10 by absolute number of calls</h2>
<h2>Top 10 by percent errored</h2>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>