<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Comparing different ways to add ints // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Comparing different ways to add ints</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/algorithms.html">algorithms</a>
                                <a class="post-category" href="/tag/hackerrank.html">hackerrank</a>
                                <a class="post-category" href="/tag/python.html">python</a>
                        </p>
                </header>
            </section>
            <h2>Puzzle</h2>
<p>Given 2 ints represented as array of digits in order (eg. 843 = [8, 4, 3]), implement a function that returns a sum of the 2 ints in the same format.</p>
<p>eg. [8, 4, 3] + [1, 8, 2] = [1, 0, 2, 5]</p>
<h2>Idea</h2>
<p>Compare recursive and iterative solution. Time them and see how long each runs on the same input.</p>
<h3>Wrapper to time each function call</h3>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">timeit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">elapsedTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span>
        <span class="n">time_as_string</span> <span class="o">=</span> <span class="s">&#39;{:.6f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsedTime</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">time_as_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfunc</span>
</pre></div>


<p>and then we wrap each method call with the wrapper. This takes the wrapped function, passes the original args, times how long it took to execute and returns a tuple of function return value and time_as_string.</p>
<div class="highlight"><pre><span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">iter_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
</pre></div>


<p>For a fair comparison, both should have the same design and stack allocation strategy. Hence both iter_sum and recur_sum methods reverse the incoming arrays and return the result of the helper. The iterative method calculates everything in 1 stack frame. The recursive recur_sum_helper (by definition) creates a stack frame for each call. </p>
<p>As both _sum methods prepare and pass reversed arrays into helper methods, the helper methods return the result array in the opposite order. Both _sum methods reverse the return arrays before returning.</p>
<h4>Bug</h4>
<p>In the first version of the recur_sum_helper and wrapper there was a bug. When inspected, the recursive solution returned an array much longer than expected. This was the wrapper's fault, as was proven by running the methods without wrapping. </p>
<p>My hypothesis: The timeit wrapper method tooks the args and kwargs of the wrappee and kept them across runs. From the second interation onwards, the res array in the wrapped recur_sum_helper was kept inside the wrapper. Adding </p>
<div class="highlight"><pre>    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</pre></div>


<p>solved the problem. </p>
<h3>Recursive</h3>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="p">[],</span> <span class="n">carry</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c"># guarantee it doesn&#39;t change array outside func scope</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>

    <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>
</pre></div>


<p>Recieves already reversed arrays of digits. Idx initialised at 0, which sets it to the rightmost digit. 
The final return statement will activate once idx exhausts both arrays (i.e. incremented beyond both lengths). If the carry bit has been carried over from the previous stack frame, which called this last stack frame, add 1 to the end of the array and return the result. </p>
<p>Otherwise, if either of the arrays is exhausted, add the ints from the other array keeping carry bit in mind. All 3 cases (arr1 - exhausted, arr2 - not; arr2 - exhaused, arr1 - not; arr1 and arr2 still not exhausted) use divmod function to set the carry bit and item_to_add. On Intel CPUs this should happen in 1 instruction. The only difference is using both arrays if both are still not exhausted.</p>
<p>Having done some Clojure, functional tools like map and reduce made it feel that a recursive solution was going to be clean and simple. Handling the same edge cases across different </p>
<h3>Iterative</h3>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">iter_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">)):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">):</span>
            <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
            <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>