<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>My blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2018-02-12T23:20:00+00:00</updated><entry><title>Search text fast or die trie-ing</title><link href="/search-text-fast-or-die-trie-ing.html" rel="alternate"></link><updated>2018-02-12T23:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2018-02-12:search-text-fast-or-die-trie-ing.html</id><summary type="html">&lt;p&gt;Benchmarking the Python and C implementation of a trie-as-a-dictionary. &lt;/p&gt;
&lt;h2&gt;tl; dr&lt;/h2&gt;
&lt;p&gt;Writing own toy Python extension in C is fun, gives you a big performance win for limited investment and is easy thanks to great documentation and tooling. &lt;/p&gt;
&lt;h2&gt;What does C give you over Python?&lt;/h2&gt;
&lt;p&gt;C is closer to the metal, saves memory for data structures and is compiled. The cTrie is implemented as a struct with 1 trie_node object and the PyObject_Head that is compulsory for Python extensions. This is lighter on methods and thus memory used than the PyTrie class, which inherits unnecessary methods from the Base Object. &lt;/p&gt;
&lt;p&gt;As far as I know, Python converts variable names to memory addresses, so using pointers in the cTrie implementation doesn't give an advantage over PyTrie.&lt;/p&gt;
&lt;p&gt;Characters are the same in C and Python - the CPython interpreter caches useful strings and individual characters are resolved as pointers to the immutable strings of characters. &lt;/p&gt;
&lt;h2&gt;How much infra is there for writing Python extensions in C?&lt;/h2&gt;
&lt;p&gt;Loads. The CPython developers are great, there are helper methods to parse arguments passed to the function and cast them to given C types, debug print method, method to build return values and for the method definitions. The documentation is detailed and includes a tutorial, which helps. &lt;/p&gt;
&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;After installing debug symbols&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install python3.5-dbg
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Compile the extension with &lt;code&gt;-g -O0&lt;/code&gt; flags to make sure debug sybmols are avaiable and nothing is optimised out. &lt;/p&gt;
&lt;p&gt;Run the line below (inside emacs or terminal).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gdb -ex r --args python3 test.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can step through the programme, look at the backtrace and examine registers. &lt;/p&gt;
&lt;h2&gt;What's inside the shared library&lt;/h2&gt;
&lt;p&gt;Using readelf (better than objdump according to &lt;a href="https://stackoverflow.com/questions/8979664/readelf-vs-objdump-why-are-both-needed"&gt;this&lt;/a&gt;), we can examine the functions of the shared library.&lt;/p&gt;
&lt;h2&gt;What performs better - compiled C or Python?&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;building&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ctrie&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;extension&lt;/span&gt;
&lt;span class="n"&gt;creating&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="n"&gt;creating&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;3.5&lt;/span&gt;
&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gcc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pthread&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;DNDEBUG&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fwrapv&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wall&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wstrict&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;prototypes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fstack&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;protector&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;strong&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wformat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Werror&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D_FORTIFY_SOURCE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fPIC&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;python3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;3.5&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O3&lt;/span&gt;
&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gcc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pthread&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;shared&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Bsymbolic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Bsymbolic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;relro&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Bsymbolic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;relro&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fstack&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;protector&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;strong&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wformat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Werror&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D_FORTIFY_SOURCE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;3.5&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;petr_tik&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Coding&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bivittatus&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ctrie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpython&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;
&lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;echo 3 &amp;gt; /proc/sys/vm/drop_caches&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;python3&lt;/span&gt; &lt;span class="n"&gt;benchmark&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;span class="n"&gt;PyTrie&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000009&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;instantiate&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;adding&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.231256&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="mi"&gt;18000&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000593&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;instantiate&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;adding&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.239599&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="mi"&gt;18000&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.005769&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.001648&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;look&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;cTrie&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000529&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;instantiate&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;adding&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.012475&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="mi"&gt;18000&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000002&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;instantiate&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;adding&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.011485&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="mi"&gt;18000&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000142&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;span class="n"&gt;Takes&lt;/span&gt; &lt;span class="mf"&gt;0.000375&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;look&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The C trie is faster in all cases apart from instantiating a new trie. As far as I understand, this is related to the fact that the bytecode for PyTrie is preloaded by the CPython interpreter, while the C library needs to load when it's first called. After that the speed improvde is at least a factor of 2. Searching for words inside the trie is at least an order of magnitude faster. &lt;/p&gt;
&lt;h2&gt;Where is the source?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/petr-tik/bivittatus"&gt;On my GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Why is it called bivittatus?&lt;/h2&gt;
&lt;p&gt;Bivittatus &lt;code&gt;is one of the five largest species of snakes in the world&lt;/code&gt; according to wikipedia. Seemed appropriate to name a Python extension after one of the longest Python in the world.&lt;/p&gt;</summary><category term="python"></category><category term="c"></category></entry><entry><title>Diving into CPython GC module</title><link href="/diving-into-cpython-gc-module.html" rel="alternate"></link><updated>2017-08-05T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-08-05:diving-into-cpython-gc-module.html</id><summary type="html">&lt;p&gt;This is a deep dive into the source code for &lt;code&gt;Modules/gcmodule.c&lt;/code&gt; inspired by a previous &lt;a href="/notes-on-pythons-gc.html"&gt;blogpost&lt;/a&gt;, which gave a high-level overview of the GC mechanism in CPython. I am doing my best in reading the source, documentation and commit messages to outline my understanding of the internals. If you see an error, missing information or a typo, please &lt;a href="https://github.com/petr-tik/petr-tik.github.io/issues"&gt;open an issue&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Why does Python need garbage collection?&lt;/h1&gt;
&lt;p&gt;As a managed memory runtime, CPython doesn’t give the programmer direct memory control. This makes it easier to write code without worrying about allocating memory for your data. Garbage collection is a mechanism for regularly checking that pre-allocated memory is still in use. Being in use means other objects still refer to you for something and your reference count is above 0. Once an object isn't in use, the memory allocated for it is collected and becomes available to future allocations.&lt;/p&gt;
&lt;h1&gt;What kind of GC does Python use?&lt;/h1&gt;
&lt;p&gt;Python uses a generation-based ref-counting GC. The number of generations is defined in a macro as 3, where 0th generation keeps track of most recently allocated objects, 2nd generation of long lived objects. Every &lt;code&gt;gc_generation&lt;/code&gt; has a threshold (number of objects after which a collection is performed) as defined below (taken from gcmodule.c).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;gc_generation&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;threshold&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* collection threshold */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* count of allocations or collections of younger&lt;/span&gt;
&lt;span class="cm"&gt;                  generations */&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cp"&gt;#define NUM_GENERATIONS 3&lt;/span&gt;
&lt;span class="cp"&gt;#define GEN_HEAD(n) (&amp;amp;generations[n].head)&lt;/span&gt;

&lt;span class="cm"&gt;/* linked lists of container objects */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;gc_generation&lt;/span&gt; &lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NUM_GENERATIONS&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* PyGC_Head,                               threshold,      count */&lt;/span&gt;
    &lt;span class="p"&gt;{{{&lt;/span&gt;&lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}},&lt;/span&gt;           &lt;span class="mi"&gt;700&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;            &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{{{&lt;/span&gt;&lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}},&lt;/span&gt;           &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{{{&lt;/span&gt;&lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}},&lt;/span&gt;           &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;What are the thresholds?&lt;/h2&gt;
&lt;p&gt;The thresholds are initiated at 700, 10 and 10 respectively. This means GC will be kicked off for 0th generation, when we allocate 700th object or promote 10 objects to either 1st or 2nd generation. The first generation can only have 10 objects (objects that survive collection move to a higher generation). The second generation is the oldest, so objects that survive collection move nowhere and stay in the second generation. The difference between 700 and 10 relies on the heuristic that few objects will survive after 1 generation. This optimises the effect of GC on runtime performance working with newly allocated objects. To improve the performance wrt to long-living objects another heuristic is used to avoid collecting the oldest generation, which can have an unlimited number of objects.&lt;/p&gt;
&lt;h1&gt;How is GC invoked?&lt;/h1&gt;
&lt;h2&gt;By the interpreter&lt;/h2&gt;
&lt;p&gt;Most of the time, the call to start a GC cycle is done as a result of allocating a new object. After a new object has been allocated, &lt;code&gt;_PyObject_GC_Alloc&lt;/code&gt; checks if it exceeds the threshold for 0th generation and calls &lt;code&gt;collect_generations&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;_PyObject_GC_Alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;use_calloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;basicsize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;[...]&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyGC_Head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;basicsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;use_calloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;PyObject_Calloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;[...]&lt;/span&gt;
    &lt;span class="n"&gt;_PyGCHead_SET_REFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GC_UNTRACKED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* number of allocated GC objects */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;threshold&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="n"&gt;enabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;threshold&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;collecting&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;PyErr_Occurred&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;collecting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;collect_generations&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;collecting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FROM_GC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;collect_generations&lt;/code&gt; method finds the oldest generation with more objects than the threshold allows and collects everything up to that generation. &lt;code&gt;collect_generations&lt;/code&gt; calls &lt;code&gt;collect_with_callbacks&lt;/code&gt;, which calls &lt;code&gt;collect&lt;/code&gt; for the given generation.&lt;/p&gt;
&lt;p&gt;This method is used by &lt;code&gt;_PyObject_GC_Calloc&lt;/code&gt; and &lt;code&gt;_PyObject_GC_Malloc&lt;/code&gt;, which are called by &lt;code&gt;PyObject_GC_New&lt;/code&gt; - the standard way to allocate new list, dictionary, class, iterator, set, slice and many other built-in Python types.&lt;/p&gt;
&lt;h2&gt;By the user/programmer&lt;/h2&gt;
&lt;p&gt;Users can directly call &lt;code&gt;gc.collect&lt;/code&gt; to run a full collection. &lt;code&gt;gc.collect&lt;/code&gt;, its C equivalent - &lt;code&gt;PyGC_Collect&lt;/code&gt; and &lt;code&gt;collect_generations&lt;/code&gt;, which uses pre-registered callbacks and executes them before and after the gc has been called. &lt;/p&gt;
&lt;h1&gt;collect method&lt;/h1&gt;
&lt;p&gt;However you invoke the GC, it all comes down to the &lt;code&gt;collect&lt;/code&gt; method, which takes the generation number for which the collection is performed and starts the GC cycle. Below is the main collect method found in &lt;a href="https://github.com/python/cpython/blob/3.6/Modules/gcmodule.c#L899-L1081"&gt;Modules/gcmodule.c&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;How do you prepare a generation for collection?&lt;/h1&gt;
&lt;p&gt;To prepare a genertion for collection, we merge all younger generations into the generation that is currently being collected. &lt;code&gt;gc_list_merge&lt;/code&gt; appends the younger generation to the list of the currently collected generation.&lt;/p&gt;
&lt;h2&gt;gc_list_merge&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* append list `from` onto list `to`; `from` becomes an empty list */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
static&lt;span class="w"&gt; &lt;/span&gt;void&lt;span class="w"&gt;&lt;/span&gt;
gc_list_merge&lt;span class="o"&gt;(&lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;from&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;tail&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;assert&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;gc_list_is_empty&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tail&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;gc_list_init&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By creating a variable for &lt;code&gt;tail&lt;/code&gt;, we can save the pointer to the last node in the &lt;code&gt;to&lt;/code&gt; list. First, we link the second node in the from list with the end of the to list using the &lt;code&gt;tail&lt;/code&gt; variable. The second node in the &lt;code&gt;from&lt;/code&gt; list becomes the head of the merged list. At the end, we make the head node of the &lt;code&gt;to&lt;/code&gt; list point its prev pointer to the last node of the &lt;code&gt;from&lt;/code&gt; list and the next pointer of the last node of the &lt;code&gt;from&lt;/code&gt; list to the first node of the &lt;code&gt;to&lt;/code&gt; list. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;gc_list_init&lt;/code&gt; makes the sentinel node points both pointers to itself. The first node in any gc list is therefore always a sentinel node. &lt;/p&gt;
&lt;p&gt;Therefore we merge the &lt;code&gt;from&lt;/code&gt; list to the left of the &lt;code&gt;to&lt;/code&gt; list. In a full collection, the 0th generation is merged with the 2nd first. The result, where the nodes from the 0th collection are to the left of the nodes from the 2nd collection, is merged with the 1st generation. This results in the following order:&lt;/p&gt;
&lt;p&gt;1st generation -&amp;gt; 0th generation -&amp;gt; 2nd generation&lt;/p&gt;
&lt;h2&gt;After merging&lt;/h2&gt;
&lt;p&gt;Having defined young earlier (currently collected generation) and old (generation right of current) now assign values to them. &lt;code&gt;young&lt;/code&gt; acquires the value of the gc_list, which now contains the result of merging all previous generations with the current. &lt;code&gt;old&lt;/code&gt; is set to the head of generation to the right, if it exists. eg. when generation = 2, old = young. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;update_refs&lt;/code&gt; and then &lt;code&gt;substract_refs&lt;/code&gt; prepares the young generation of collection. At the start of a collection, &lt;code&gt;update_refs&lt;/code&gt; copies the true refcount to &lt;code&gt;gc.gc_refs&lt;/code&gt;, for each object in the generation being collected. &lt;code&gt;update_refs&lt;/code&gt; copies refcnt value from PyObject’s objcnt to gc’s gc_refs field. This field is set to different statuses to signal, if the object is still attached to any other objects. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;subtract_refs&lt;/code&gt; then adjusts &lt;code&gt;gc_refs&lt;/code&gt; so that it equals to the number of times an object is referenced directly from outside the generation being collected. This deals with cycle-detection. Whenever another object starts using PyObject op, Py_INCREF is called on this object. Py_INCREF increments the number of total references that have been given out and the objcnt of the given object.&lt;/p&gt;
&lt;h2&gt;What happens in a collection?&lt;/h2&gt;
&lt;h3&gt;Tentatively move unreachable objects&lt;/h3&gt;
&lt;p&gt;After all the objects are merged into the &lt;code&gt;young&lt;/code&gt; generation list, another list is initiated to keep track of unreachable objects. &lt;code&gt;move_unreachable&lt;/code&gt; walks across the &lt;code&gt;young&lt;/code&gt; list, where objects have had their &lt;code&gt;ob_refcnt&lt;/code&gt; and &lt;code&gt;gc_refs&lt;/code&gt; updated. Those with refcount &amp;lt;= 0 are moved into unreachable list and its &lt;code&gt;gc_refs&lt;/code&gt; is set to &lt;code&gt;GC_TENTATIVELY_UNREACHABLE&lt;/code&gt;. Being moved into the unreachable list at this point is no guarantee of being garbage collected, as these objects will be assessed again. The objects that remain in the &lt;code&gt;young&lt;/code&gt; list are guaranteed to avoid collection and are promoted to the &lt;code&gt;old&lt;/code&gt; generation.&lt;/p&gt;
&lt;h3&gt;Promote survived objects to the older generation&lt;/h3&gt;
&lt;p&gt;The objects in young that haven't been marked as &lt;code&gt;GC_TENTATIVELY_UNREACHABLE&lt;/code&gt; are definitely getting promoted to the next generation by merging &lt;code&gt;young&lt;/code&gt; with &lt;code&gt;old&lt;/code&gt;. Now, &lt;code&gt;young&lt;/code&gt; contains the sentinel node, &lt;code&gt;old&lt;/code&gt; all the objects that survived this collection and &lt;code&gt;unreachable&lt;/code&gt; objects that may or may not be collected.&lt;/p&gt;
&lt;h3&gt;Deal with finalizers&lt;/h3&gt;
&lt;p&gt;At this point, the objects in &lt;code&gt;unreachable&lt;/code&gt; are potentially reachable. Those with finalizers might still be reachable. If so, we can recover them.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;move_legacy_finalizers&lt;/code&gt; moves the objects in &lt;code&gt;unreachable&lt;/code&gt; with &lt;code&gt;tp_del&lt;/code&gt; slots into &lt;code&gt;finalizers&lt;/code&gt;. Objects moved into &lt;code&gt;finalizers&lt;/code&gt; have &lt;code&gt;gc_refs&lt;/code&gt; set to &lt;code&gt;GC_REACHABLE&lt;/code&gt;; the objects remaining in &lt;code&gt;unreachable&lt;/code&gt; are left at &lt;code&gt;GC_TENTATIVELY_UNREACHABLE&lt;/code&gt;. Even now, the objects in &lt;code&gt;unreachable&lt;/code&gt; are potentially alive. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;move_legacy_finalizers(PyGC_Head *unreachable, PyGC_Head *finalizers)&lt;/code&gt; moves objects that are reachable from &lt;code&gt;finalizers&lt;/code&gt;, from the &lt;code&gt;unreachable&lt;/code&gt; set into &lt;code&gt;finalizers&lt;/code&gt; set.&lt;/p&gt;
&lt;h3&gt;clear weakrefs&lt;/h3&gt;
&lt;h4&gt;What are weak references?&lt;/h4&gt;
&lt;p&gt;Weak references are used to track objects that shouldn't be uncollectable only when tracked. Caching or mapping keys to large objects has a large memory footprint. Creating a reference between many large objects and their descriptions (like keys in a dictionary) would make them uncollectable, until the dictionary/cache becomes unreachable. Creating a weak reference, however, doesn't contribute to the &lt;code&gt;gc_refs&lt;/code&gt; count, so when the object has no real references outside its cache/container, it can be collected. Tidies up all objects in &lt;code&gt;unreachable&lt;/code&gt; and guarantees that none of them have weakrefs to other objects.&lt;/p&gt;
&lt;h4&gt;How are they tidied up?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;handle_weakrefs&lt;/code&gt; iterates over the objects in &lt;code&gt;unreachable&lt;/code&gt;, registering callbacks from each weakref. If the callback revives the object, we promote it to the &lt;code&gt;old&lt;/code&gt; generation.&lt;/p&gt;
&lt;h3&gt;check and revive garbage if necessary&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;finalise_garbage&lt;/code&gt; calls objects' custom destructors on the objects currently deemed unreachable. Calling a finalizer might reset &lt;code&gt;gc_refs&lt;/code&gt; back to &lt;code&gt;GC_REACHABLE&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;check_garbage&lt;/code&gt; also uses &lt;code&gt;substract_refs&lt;/code&gt; to confirm there are no references to the objects in &lt;code&gt;unreachable&lt;/code&gt; from outside the set. If there is at least one, it means the whole cycle is accessible from the outside, so &lt;code&gt;revive_garbage&lt;/code&gt; makes every object in &lt;code&gt;unreachable&lt;/code&gt; &lt;code&gt;GC_REACHABLE&lt;/code&gt; again and merges the whole list with &lt;code&gt;old&lt;/code&gt; generation.&lt;/p&gt;
&lt;h3&gt;delete garbage&lt;/h3&gt;
&lt;p&gt;Even if an object finds itself in the &lt;code&gt;unreachable&lt;/code&gt; list at this stage, it is not doomed! There is still hope, all the way up until garbage is deleted. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;delete_garbage&lt;/code&gt; traverses through the &lt;code&gt;unreachable&lt;/code&gt; list and if it has a &lt;code&gt;tp_clear&lt;/code&gt; method, invokes it. If the object is still alive after that, its &lt;code&gt;gc_refs&lt;/code&gt; is set to GC_REACHABLE and it's moved to the &lt;code&gt;old&lt;/code&gt; generation. &lt;/p&gt;
&lt;p&gt;The big life lesson is: if you are a python object and no one is reaching out to you, you have legacy finalizers, and you have no weak references - don't despair. If your &lt;code&gt;tp_clear&lt;/code&gt; method changes your &lt;code&gt;gc_refs&lt;/code&gt; you might come back to life and get promoted to older generation.&lt;/p&gt;
&lt;h3&gt;clear freelists&lt;/h3&gt;
&lt;p&gt;If it's a full collection, freelists for different data structures are cleared. More detail below.&lt;/p&gt;
&lt;h1&gt;What is the difference between a full and a normal collection?&lt;/h1&gt;
&lt;h2&gt;Full collection runs less frequently using a heuristic&lt;/h2&gt;
&lt;p&gt;The first 2 generations are bounded by thresholds, whereas generation 2 can grow without a limit. Collecting all generations (called full collection) including the 2nd every time, would lead to quadratic running time. We can either skip objects or perform fewer collections to help our runtime. A heuristic is used to run fewer collections by calculating a ratio of objects that survived a full collection over those that that are yet to go through a full collection. When the ratio is greater than 4, we perform a full collection.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt;
&lt;span class="nf"&gt;collect_generations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NUM_GENERATIONS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;generations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;threshold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;NUM_GENERATIONS&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;long_lived_pending&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;long_lived_total&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;collect_with_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We invoke a full collection if more than 25% of the objects have been allocated since the last full collection.&lt;/p&gt;
&lt;h2&gt;Dictionaries are untracked&lt;/h2&gt;
&lt;h3&gt;What kind of objects are tracked?&lt;/h3&gt;
&lt;p&gt;Python has a mix of immutable and mutable data structures. If an immutable object has many references to it, none of them can change it, so there is no need to track the references. Tuples and strings are strictly immutable in python. Every modification of an existing tuple/string, allocates a new object of the same type, applies the transformation in-memory and copies the result into the newly allocated object. Tuples are slightly different from strings, because they are container objects i.e. they keep track of other objects inside. An immutable container like tuple may contain a mutable object like a list, which needs GC. A completely immutable container - tuple of integers/strings will neither change as a container nor as its members. Therefore there is no need to GC track it. &lt;/p&gt;
&lt;h3&gt;Why and how do you track/untrack objects?&lt;/h3&gt;
&lt;p&gt;By default, we still track newly created tuples and leave it to the GC to untrack them. &lt;code&gt;move_unreachable&lt;/code&gt; uses &lt;code&gt;_PyTuple_MaybeUntrack&lt;/code&gt; (defined in &lt;a href="https://github.com/python/cpython/blob/3.6/Objects/tupleobject.c#L180-L203"&gt;Objects/tupleobject.c&lt;/a&gt;), which iterates over all the objects in the tuple. If there are no NULL elements (yet to be constructed), it untracks the tuple object i.e. sets its &lt;code&gt;gc_refs&lt;/code&gt; to &lt;code&gt;_PyGC_REFS_UNTRACKED&lt;/code&gt; and removes its PyGC_Head object from its generation list.&lt;/p&gt;
&lt;p&gt;Dictionaries containing only immutable objects like strings also don’t need tracking. In a full collection, we examine which dictionaries we can untrack and untrack them if the keys and values in the dictionary don't need tracking. &lt;/p&gt;
&lt;h3&gt;Protip&lt;/h3&gt;
&lt;p&gt;To optimise memory usage: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use tuples for data and &lt;code&gt;__slots__&lt;/code&gt; for your classes&lt;/li&gt;
&lt;li&gt;If using dictionaries: use immutable objects (ints, strings; NOT lists) as keys and values. &lt;/li&gt;
&lt;li&gt;If you really care about memory, write a C module that you can load into your CPython&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Surviving objects don't get promoted&lt;/h2&gt;
&lt;p&gt;There is no older generation to get promoted to. When &lt;code&gt;young != old&lt;/code&gt;, the objects that are still reachable in the &lt;code&gt;young&lt;/code&gt; list are moved to &lt;code&gt;old&lt;/code&gt;. Collecting the oldest generation means we cannot move/promote surviving objects any further.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    else {
        /* We only untrack dicts in full collections, to avoid quadratic
           dict build-up. See issue #14775. */
        untrack_dicts(young);
        long_lived_pending = 0;
        long_lived_total = gc_list_size(young);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We don't move anything anywhere, just reset &lt;code&gt;long_lived_pending&lt;/code&gt; (no object has not survived a full collection) and update &lt;code&gt;long_lived_total&lt;/code&gt; with the number of objects. &lt;/p&gt;
&lt;h2&gt;Clearing freelists&lt;/h2&gt;
&lt;p&gt;As mentioned above, freelists are cleared during full collection.&lt;/p&gt;
&lt;h3&gt;What are freelists?&lt;/h3&gt;
&lt;p&gt;Free lists are lists of primitive Python object types allocated during CPython interpreter start. Preallocating basic object types like ints, lists, dictionaries and sets helps users avoid calling &lt;code&gt;malloc&lt;/code&gt; for the first X object creations. Similarly, when an object is collected, it's just returned to the freelist of that PyObject type instead of calling &lt;code&gt;free&lt;/code&gt;. Both &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; are syscalls, hence require a context switch and unnecessarily increase latency. Only if your programme uses more objects than originally allocated, will you call malloc. Example freelist from &lt;code&gt;dictobject.c&lt;/code&gt; below&lt;/p&gt;
&lt;p&gt;The CPython interpreter allocates a list of 80 dictionary objects.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifndef PyDict_MAXFREELIST&lt;/span&gt;
&lt;span class="cp"&gt;#define PyDict_MAXFREELIST 80&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PyDict_MAXFREELIST&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Why does CPython preallocate 80 dictionaries?&lt;/h3&gt;
&lt;p&gt;The commit adding free_lists and their sizes is an old svn commit with more than a dozen of features in one without explanation for any of the values. Some make more sense - powers of 2 like 1024, 4096, but 80 is somewhat confusing. Given that the size of a dictionary is 400 bytes, 80 dictionaries is 32000 bytes, which might be friendlier to memory.&lt;/p&gt;
&lt;h3&gt;How is freelist used to alloc/free dictionaries?&lt;/h3&gt;
&lt;p&gt;In the function that creates a new dictionary from given keys and values, we first check if we can use a pre-allocated dictionary from the freelist. If all dictionaries in the freelist have been used already (numfree &amp;gt;= 80), we have to allocate our own. Otherwise, Using numfree as index into the array of preallocated data types (eg. dictionaries), we assign mp to a dictionary from the list. Interestingly enough, &lt;code&gt;if (numfree)&lt;/code&gt; will also execute the branch, if numfree is negative, which is semantically incorrect, but not impossible.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;new_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDictKeysObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To deallocate we return the dictionary to the freelist, if we still haven't used up the whole list. If we haven't allocated all dictionaries from the freelist, it means, we can return the current dictionary to the list.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;dict_dealloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;PyDict_MAXFREELIST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Py_TYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;PyDict_Type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;How are freelists cleared?&lt;/h3&gt;
&lt;p&gt;Each of the listed types in their &lt;code&gt;Objects/dictobject.c&lt;/code&gt; source files have a method for clearing its freelist. Curiously, the &lt;code&gt;PyDict_ClearList&lt;/code&gt; method returns the number of freed objects, but all invocations of the method cast the return type to void, making you wonder, why it returns anything in the first place.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;PyDict_ClearFreeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDict_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;PyObject_GC_Del&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;PyObject_FREE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys_free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Iterates over the freelist, GC_deleting each object in the list. In the end, we have numfree set to 0 and a freelist full of objects ready to be used again.&lt;/p&gt;
&lt;h2&gt;What does the collect method return?&lt;/h2&gt;
&lt;p&gt;Returns a static signed size_t int. Input is generation (between 0 and 2 - higher is older), pointer to a variable tracking the &lt;code&gt;n\_collected&lt;/code&gt; objects so far, &lt;code&gt;uncollectable&lt;/code&gt; and &lt;code&gt;nofail&lt;/code&gt; variable. Looking ahead &lt;code&gt;nofail&lt;/code&gt; is only used once to decide if an error message should be printed to terminal. Both Py_ssize_t objects - &lt;code&gt;n\_collected&lt;/code&gt; and &lt;code&gt;n\_uncollectable&lt;/code&gt; - will be updated in-place (at their addresses) with m and n respectively.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* # objects collected */&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* # unreachable objects that couldn&amp;#39;t be collected */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Why are variables like m and n used?&lt;/h2&gt;
&lt;p&gt;I guess programmers in the 90s/early 00s were paid inversely proportionally to the number of chars they typed. That would explain &lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;creat&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;. Apart from that the gcmodule is a joy to read through - well commented, with descriptive commit messages and a separate .rst doc file.&lt;/p&gt;
&lt;h1&gt;What is PyGC_Head and how is it related to PyObject?&lt;/h1&gt;
&lt;h3&gt;PyGC_Head&lt;/h3&gt;
&lt;p&gt;Most variables are of type PyGC_Head, whose definition is in &lt;a href="https://github.com/python/cpython/tree/3.6/Include/objimpl.h#L251-L259"&gt;objimpl.h&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* GC information is stored BEFORE the object structure. */&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef Py_LIMITED_API&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc_prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;gc_refs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* force worst-case alignment */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyGC_Head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The meaty part of the type is pointers of the same type to next and previous &lt;code&gt;_gc_head&lt;/code&gt; types and the &lt;code&gt;gc_refs&lt;/code&gt; that keeps track of the number of references.&lt;/p&gt;
&lt;h3&gt;Why double dummy?&lt;/h3&gt;
&lt;p&gt;Paraphrasing the commit message - the &lt;code&gt;double dummy&lt;/code&gt; is to make sure 8-byte alignment won't break. When 8-byte alignment is required, padding is added, otherwise, there won't be any change.&lt;/p&gt;
&lt;h3&gt;Why recursively defined gc struct?&lt;/h3&gt;
&lt;p&gt;This uses a sentinel doubly linked list. An empty linked list contains one node, whose &lt;code&gt;.gc_prev&lt;/code&gt; and &lt;code&gt;.gc_next&lt;/code&gt; link to the node itself. Appending nodes to the end of a list means linking the &lt;code&gt;.gc_next&lt;/code&gt; and &lt;code&gt;.gc_prev&lt;/code&gt; of the new_node to the head of the list and last element of the list respectively. The first element is a dummy - sentinel - node.  That's why all list traversal operations begin initiate &lt;code&gt;gc = list-&amp;gt;gc.gc_next&lt;/code&gt; as below&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt;
&lt;span class="nf"&gt;gc_list_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and to check emptiness you need to compare pointers between the head and the first next element after the sentinel. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;gc_list_is_empty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;PyObject&lt;/h2&gt;
&lt;p&gt;The PyObject struct is defined in &lt;a href="https://github.com/python/cpython/3.6/blob/Include/object.h"&gt;Include/object.h&lt;/a&gt;. Contains the reference count and type of the object.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Define pointers to support a doubly-linked list of all live heap objects. */&lt;/span&gt;
&lt;span class="cp"&gt;#define _PyObject_HEAD_EXTRA            \&lt;/span&gt;
&lt;span class="cp"&gt;    struct _object *_ob_next;           \&lt;/span&gt;
&lt;span class="cp"&gt;    struct _object *_ob_prev;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_object&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;_PyObject_HEAD_EXTRA&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;ob_refcnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_typeobject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ob_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;PyObject to/from PyGC_Head&lt;/h2&gt;
&lt;p&gt;There are helper method defined as macros to convert between &lt;code&gt;PyObject&lt;/code&gt; and &lt;code&gt;PyGC_Head&lt;/code&gt;, to read/write reference counts from one to the other. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Get an object&amp;#39;s GC head */&lt;/span&gt;
&lt;span class="cp"&gt;#define AS_GC(o) ((PyGC_Head *)(o)-1)&lt;/span&gt;

&lt;span class="cm"&gt;/* Get the object given the GC head */&lt;/span&gt;
&lt;span class="cp"&gt;#define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;gc_refs&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gc_refs&lt;/code&gt; values determine if an object should be collected. When an object is malloc’ed, its &lt;code&gt;gc_refs&lt;/code&gt; is set to &lt;code&gt;GC_UNTRACKED&lt;/code&gt;, because it’s absent from any generation list. &lt;/p&gt;
&lt;p&gt;As soon as it’s added to a generation list its &lt;code&gt;gc_refs&lt;/code&gt; is updated to GC_REACHABLE.&lt;/p&gt;
&lt;p&gt;During a collection &lt;code&gt;gc_refs&lt;/code&gt; may take other values. The most important is GC_TENTATIVELY_UNREACHABLE, which means the object has been moved to the unreachable set temporarily. Even when ref updating is over and an object is GC_TENTATIVELY_UNREACHABLE, it may be made reachable again. &lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This blog is a read-through of the &lt;code&gt;Modules/gcmodule.c&lt;/code&gt; of the CPython interpreter. I explained my understanding of the &lt;code&gt;collect&lt;/code&gt; method, which is called by &lt;code&gt;PyGC_collect&lt;/code&gt; or &lt;code&gt;_PyObject_GC_Alloc&lt;/code&gt;. The collecting process is outlined from preparing the generation, moving unreachable objects, recovering or deleting garbage to collecting and returning stats. The difference between a full collection and a collection of generation 0 or 1 is explained. Some heuristics and tips to use CPython efficiently were explained and internals of object allocation/collection were outlined. &lt;/p&gt;</summary><category term="python"></category><category term="gc"></category><category term="memory"></category></entry><entry><title>Comparing different ways to add ints II</title><link href="/comparing-different-ways-to-add-ints-ii.html" rel="alternate"></link><updated>2017-07-16T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-07-16:comparing-different-ways-to-add-ints-ii.html</id><summary type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;As outlined in &lt;a href="/comparing-different-ways-to-add-ints-i.html"&gt;part 1&lt;/a&gt;, we are comparing recursive and iterative implementations of long arithmetic of 2 arrays. As seen in the chart at the bottom of the post, there is a sudden jump in execution times of the recursive function, when the length of array becomes ~900 ints. Using the &lt;code&gt;cProfile&lt;/code&gt; and &lt;code&gt;line_profile&lt;/code&gt; modules in Python, this increase in execution times is investigated in this post. First cProfile was used to record and examine the execution times for &lt;code&gt;recur_sum&lt;/code&gt; and &lt;code&gt;iter_sum&lt;/code&gt;. After the bottlenecks were located, &lt;code&gt;line_profiler&lt;/code&gt; was used to profile each function with higher granularity. To guarantee consistent analysis both implementations will be benchmarked with line profiling enabled. &lt;/p&gt;
&lt;h2&gt;Refactoring&lt;/h2&gt;
&lt;p&gt;The script from part 1 had to be changed to profile the relevant function calls and save the results. This effectively wraps the function calls with cProfiler and then saves the results into a .dmp type. Afterwards results are plotted.&lt;/p&gt;
&lt;h3&gt;Plot results&lt;/h3&gt;
&lt;p&gt;Instead of using a scatter plot, normal plot was used, which made the increase in gradient more obvious. It also takes the right and left limits to the x values (lengths of the array). Setting xlim to the plot will help us focus the picture. We will not exceed recursion depth in this example. Hence we won't be marking the last point in recursive times.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;plot_results_for_cprofile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Size of input arrays&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Time to calculate sum (ms)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Comparing iterative vs recursive sum methods&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
    &lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recurs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;

    &lt;span class="c"&gt;# plot iterative times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# plot recursive times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;green&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;plot_sum_ints.png&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;savefig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dpi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Saved plot as {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Profile run&lt;/h3&gt;
&lt;p&gt;Profile run method instantiates 2 &lt;code&gt;cProfile.Profile()&lt;/code&gt; classes for iterative and recursive solution profiling. Looping over different array lengths, the &lt;code&gt;iter_sum&lt;/code&gt; and &lt;code&gt;recur_sum&lt;/code&gt; solutions are profiled. The profiling information is saved to disk using the &lt;code&gt;dump_stats()&lt;/code&gt; method, which takes a string for argument name. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;profile_run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cProfile&lt;/span&gt;
    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;iter_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

        &lt;span class="n"&gt;pr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cProfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Profile&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cProfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Profile&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;iter_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_recur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recur_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recur_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_recur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;plot_results_for_cprofile&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Dumping stats&lt;/h3&gt;
&lt;p&gt;Used the length of input arrays as id of this profiler run. Looking at the &lt;a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/cProfile.py#L44-L48"&gt;source&lt;/a&gt; for cProfile.Profile.dump_stats()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;marshal&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_stats&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;marshal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We see that it uses the marshal module. From the &lt;a href="https://docs.python.org/3/library/marshal.html"&gt;documentation&lt;/a&gt;, we know that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Details of the format are undocumented on purpose; it may change between Python versions (although it rarely does).&lt;/p&gt;
&lt;p&gt;This is not a general "persistence" module. For general persistence and transfer of Python objects through RPC calls, see the modules :mod:&lt;code&gt;pickle&lt;/code&gt; and :mod:&lt;code&gt;shelve&lt;/code&gt;. The :mod:&lt;code&gt;marshal&lt;/code&gt; module exists mainly to support reading and writing the "pseudo-compiled" code for Python modules of :file:&lt;code&gt;.pyc&lt;/code&gt; files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you're serializing and de-serializing Python objects, use the :mod:&lt;code&gt;pickle&lt;/code&gt; module instead -- the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal.&lt;/p&gt;
&lt;p&gt;The :mod:&lt;code&gt;marshal&lt;/code&gt; module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What joy! &lt;code&gt;cProfile&lt;/code&gt; (the builtin python profiler) uses a badly documented, backwards-incompatible, insecure module with incomplete support for Python types.&lt;/p&gt;
&lt;h3&gt;Line profiling&lt;/h3&gt;
&lt;p&gt;Line profiling was implemented by changing the code for the &lt;code&gt;timeit&lt;/code&gt; decorator function. This allowed repeat measurements to stay consistent between recursive and iterative methods. Assuming that the overhead of line profiling of the recursive and iterative solution is in the same order of magnitude, wrapping both &lt;code&gt;recur_sum&lt;/code&gt; and &lt;code&gt;iter_sum&lt;/code&gt; wasn't expected to change the difference between them too much. &lt;code&gt;recur_sum_helper&lt;/code&gt; and &lt;code&gt;iter_sum_helper&lt;/code&gt; had to be moved above &lt;code&gt;timeit&lt;/code&gt; in the source code (reasons below). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;str_func_to_profile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__code__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;co_names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;func_to_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="n"&gt;str_func_to_profile&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;newfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# locals() returns a dictionary, where &amp;#39;args&amp;#39; is key for local vars&lt;/span&gt;
        &lt;span class="c"&gt;# ASSUMPTION: both input arrays have the same length, use either&lt;/span&gt;
        &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;locals&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;args&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="c"&gt;# make a new instance of LineProfiler for each time iter_sum() is&lt;/span&gt;
        &lt;span class="c"&gt;# called with new input arrays&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineProfiler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;func_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func_to_prof&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;startTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func_prof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;startTime&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ll_{}_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;str_func_to_profile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;time_as_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{:.6f}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_as_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newfunc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Below is a quick introduction to python decorators and how the timeit function had to change to include line profiling.&lt;/p&gt;
&lt;h4&gt;Decorators are evaluated at runtime&lt;/h4&gt;
&lt;p&gt;When a python module is loaded or runs, the wrappers are evaluated, as soon as they are encountered. Regardless if the wrapped function is even called anywhere in the module, the decorator processes and returns the new function, as soon as it is given a function to wrape. When the wrapped function is called, it has already been modified, so the function being executed is function that the decorator returned, when it was evaluated earler. To prove that decorators work at wrap-time, not call-time, set breakpoits &lt;code&gt;pdb.set_trace()&lt;/code&gt; as below. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pdb&lt;/span&gt;
&lt;span class="n"&gt;pdb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_trace&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# breakpoint 1&lt;/span&gt;

&lt;span class="nd"&gt;@timeit&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iter_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r_arr2&lt;/span&gt;&lt;span class="p"&gt;)[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;pdb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_trace&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# breakpoint 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When breakpoint 1 is hit, &lt;code&gt;iter_sum&lt;/code&gt; hasn't been defined, so the Python interpreter throws a NameError. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; python3 sum_ints_as_arrays.py 
&amp;gt; /home/petr_tik/Coding/misc/misc/sum_ints_profile/sum_ints_as_arrays.py&lt;span class="o"&gt;(&lt;/span&gt;115&lt;span class="o"&gt;)&lt;/span&gt;&amp;lt;module&amp;gt;&lt;span class="o"&gt;()&lt;/span&gt;
-&amp;gt; @timeit
&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__name__
*** NameError: name &lt;span class="s1"&gt;&amp;#39;iter_sum&amp;#39;&lt;/span&gt; is not defined
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;(c)ontinuing&lt;/code&gt; to breakpoint 2, now &lt;code&gt;iter_sum&lt;/code&gt; has been defined and wrapped. &lt;code&gt;newfunc&lt;/code&gt; is the name that  came from the closure of &lt;code&gt;timeit&lt;/code&gt;. This proves that &lt;code&gt;iter_sum&lt;/code&gt; has already been wrapped by timeit, before it's first called.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; c
&amp;gt; /home/petr_tik/Coding/misc/misc/sum_ints_profile/sum_ints_as_arrays.py&lt;span class="o"&gt;(&lt;/span&gt;124&lt;span class="o"&gt;)&lt;/span&gt;&amp;lt;module&amp;gt;&lt;span class="o"&gt;()&lt;/span&gt;
-&amp;gt; @timeit
&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__name__
&lt;span class="s1"&gt;&amp;#39;newfunc&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Closures&lt;/h4&gt;
&lt;p&gt;Decorators in Python rely on the concept of closure. At the time when newfunc is defined inside the &lt;code&gt;timeit&lt;/code&gt; function, there are 3 variables available to newfunc: str_func_to_profile, func_to_prof and func (wrapped function) itself. Continuing the same pdb session, freevars inside the code object of &lt;code&gt;iter_sum&lt;/code&gt; were examined.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__code__.co_freevars
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;func&amp;#39;&lt;/span&gt;, &lt;span class="s1"&gt;&amp;#39;func_to_prof&amp;#39;&lt;/span&gt;, &lt;span class="s1"&gt;&amp;#39;str_func_to_profile&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Adding line-profiling to the decorator&lt;/h4&gt;
&lt;p&gt;Using the above and some &lt;a href="https://docs.python.org/3/library/inspect.html"&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; hackery, we access the code object of func using  &lt;code&gt;__code__&lt;/code&gt;. &lt;code&gt;co_names&lt;/code&gt; returns a tuple of names of local variables. Both input funcs - &lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt; only have 1 local variable - its helper function. &lt;code&gt;iter_sum_helper&lt;/code&gt; and &lt;code&gt;recur_sum_helper&lt;/code&gt; are above this wrapper function in the source code. This guarantees that they will be found when &lt;code&gt;globals&lt;/code&gt; is called inside the decorator. Using the string as the key, we retrieve the function object from the globals() dictionary. &lt;/p&gt;
&lt;p&gt;Originally, I made a mistake by instantiating the &lt;code&gt;LineProfiler&lt;/code&gt; class inside &lt;code&gt;timeit&lt;/code&gt;, but before &lt;code&gt;newfunc&lt;/code&gt; is defined. This made the same instance of the &lt;code&gt;LineProfiler&lt;/code&gt; object availabe to all calls of &lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt; respectively. This would append profiling results into the same file, which was later dumped under a new name. Profiling data for &lt;code&gt;recur_sum_919&lt;/code&gt; included the profiling data for all previous runs, which made it incorrect. Instead, each time a function is called, a new instance of the &lt;code&gt;LineProfiler&lt;/code&gt; is created, when the input func (&lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt;) is called. &lt;/p&gt;
&lt;p&gt;Overall running times are still collected and returned and they are expected to increase with the overhead of line profiling. The line profiler dumps stats into a file called by its function name and array length. The result and elapsed time are returned, used by &lt;code&gt;profile_run&lt;/code&gt; to collect and plot time for each function call.&lt;/p&gt;
&lt;h2&gt;Results&lt;/h2&gt;
&lt;h3&gt;Plot&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_profiler.png" /&gt;&lt;/p&gt;
&lt;p&gt;In the graph, green is still recursive, red is iterative times. There are several notables differences - times are higher overall - profiling has a noticeable overhead. The difference between iterative and recursive is still present and the shape of ups/downs is similar in both lines . There is a huge spike for the recursive solution when the input arrays are of size 907. This makes it easy to investigate function calls.&lt;/p&gt;
&lt;h3&gt;Reading the cProfile dump&lt;/h3&gt;
&lt;h4&gt;Read function&lt;/h4&gt;
&lt;p&gt;All instances of cProfile for each array length &lt;code&gt;dump_stats&lt;/code&gt; into plaintext files recur_{arr_length} or iter_{arr_length}. &lt;code&gt;read_dump.py&lt;/code&gt; is defined to print the dump to terminal to investigate, grep and read through it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pstats&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Supply a filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;stats&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pstats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Results&lt;/h4&gt;
&lt;p&gt;Using this script, we examine the dumps of recursive calls with arrays of lengths 917 and 918 (before, during and after the peak).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_917 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5542&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4625&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_918 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5548&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4630&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.039 seconds
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_919 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5554&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4635&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At the peak, the number of function calls increases by 5, but the execution time more than triples.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;petr_tik@merluza:~/Coding/misc/misc/sum_ints_profile&lt;span class="nv"&gt;$ &lt;/span&gt;./read_dump.py recur_917 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./read_dump.py recur_918 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./read_dump.py recur_919
Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_917
         &lt;span class="m"&gt;5542&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4625&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    918/1    0.010    0.000    0.011    0.011 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;

Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_918
         &lt;span class="m"&gt;5548&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4630&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.039 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    919/1    0.038    0.000    0.038    0.038 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;

Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_919
         &lt;span class="m"&gt;5554&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4635&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    920/1    0.010    0.000    0.011    0.011 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In all three (and we can assume other) instances of &lt;code&gt;recur_sum&lt;/code&gt;, nearly 100% of time is spent on recursive calls of &lt;code&gt;recur_sum_helper&lt;/code&gt;. We will need to use line_profiling to get more detail about the increase in execution times. &lt;/p&gt;
&lt;h3&gt;Reading line profiling dump&lt;/h3&gt;
&lt;h4&gt;Read function&lt;/h4&gt;
&lt;p&gt;The line_profiler module has separate function for loading stats and showing text of the stats object. For serialisation, the line profiler module uses the builtin pickle module, which has wider coverage and better support. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#! /usr/bin/env python3&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;line_profiler&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;load_stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;show_text&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Supply a filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;stats&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;load_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;show_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Results&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_917
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.006587 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;481&lt;/span&gt;      0.5      7.3      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;2&lt;/span&gt;      2.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;926&lt;/span&gt;      1.0     14.1      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;797&lt;/span&gt;      0.9     12.1      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;782&lt;/span&gt;      0.9     11.9      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;         &lt;span class="m"&gt;1109&lt;/span&gt;      1.2     16.8      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;842&lt;/span&gt;      0.9     12.8      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;564&lt;/span&gt;      0.6      8.6      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;         &lt;span class="m"&gt;1081&lt;/span&gt;      1.2     16.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.010676 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.1      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;7&lt;/span&gt;      7.0      0.1      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;10658&lt;/span&gt;  10658.0     99.8      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_918
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.034118 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;472&lt;/span&gt;      0.5      1.4      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;3&lt;/span&gt;      3.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;892&lt;/span&gt;      1.0      2.6      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;763&lt;/span&gt;      0.8      2.2      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;776&lt;/span&gt;      0.8      2.3      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;         &lt;span class="m"&gt;1062&lt;/span&gt;      1.2      3.1      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;814&lt;/span&gt;      0.9      2.4      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;542&lt;/span&gt;      0.6      1.6      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;        &lt;span class="m"&gt;28792&lt;/span&gt;     31.4     84.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.038265 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.0      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;6&lt;/span&gt;      6.0      0.0      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;38248&lt;/span&gt;  38248.0    100.0      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_919
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.006544 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;920&lt;/span&gt;          &lt;span class="m"&gt;495&lt;/span&gt;      0.5      7.6      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;2&lt;/span&gt;      2.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;920&lt;/span&gt;          &lt;span class="m"&gt;936&lt;/span&gt;      1.0     14.3      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;788&lt;/span&gt;      0.9     12.0      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;785&lt;/span&gt;      0.9     12.0      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;         &lt;span class="m"&gt;1107&lt;/span&gt;      1.2     16.9      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;827&lt;/span&gt;      0.9     12.6      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;532&lt;/span&gt;      0.6      8.1      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;         &lt;span class="m"&gt;1071&lt;/span&gt;      1.2     16.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.010754 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.1      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;6&lt;/span&gt;      6.0      0.1      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;10737&lt;/span&gt;  10737.0     99.8      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post showed the use of &lt;code&gt;cProfile&lt;/code&gt; and &lt;code&gt;line_profiler&lt;/code&gt; modules implemented as wrappers to collect and review profiling information. Decorators, which rely on the concept of closures and runtime code inspection, were explained and used for implementing profiling. The spike in execution times of the recursive solution was found using line_profiling. Given arrays of length 918, the recursive sum function for some unexplained reasons takes 28x more time to run than previous and consequent function calls. &lt;/p&gt;
&lt;h2&gt;Future work&lt;/h2&gt;
&lt;p&gt;At this point, it's best to implement tracing either inside python interpreter or from outside the process. By tracing and logging each recursively created and executed stack frame inside &lt;code&gt;recur_sum_helper&lt;/code&gt;, we can get more information about the slowdown. Another avenue for investigation can be looking into CPython source code. Methods like &lt;code&gt;list.append()&lt;/code&gt; might cause reallocation, which would slow down the execution at some stack frames. The line profiling results suggest that would be unlikely, unless they fail to time that.&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>Comparing different ways to add ints I</title><link href="/comparing-different-ways-to-add-ints-i.html" rel="alternate"></link><updated>2017-06-27T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-06-27:comparing-different-ways-to-add-ints-i.html</id><summary type="html">&lt;h2&gt;Puzzle&lt;/h2&gt;
&lt;p&gt;Given 2 ints represented as array of digits in order (eg. 843 = [8, 4, 3]), implement a function that returns a sum of the 2 ints in the same format.&lt;/p&gt;
&lt;p&gt;eg. &lt;/p&gt;
&lt;p&gt;[8, 4, 3] + [1, 8, 2] = [1, 0, 2, 5]&lt;/p&gt;
&lt;h2&gt;Idea&lt;/h2&gt;
&lt;p&gt;Implement and profile recursive and iterative solutions to the puzzle above.&lt;/p&gt;
&lt;h3&gt;Recursive solution&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# guarantee it doesn&amp;#39;t change array outside func scope&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Having done some Clojure, functional tools like map and reduce made it feel that a recursive solution was going to be concise. Handling the same edge cases across different array lengths made the implementation more heavily branched and less pretty than expected.&lt;/p&gt;
&lt;p&gt;The final return statement will activate once idx exhausts both arrays (i.e. incremented beyond both lengths). If the carry bit has been carried over from the previous stack frame, which called this last stack frame, add 1 to the end of the array and return the result. &lt;/p&gt;
&lt;p&gt;Otherwise, if either of the arrays is exhausted, add the ints from the other array keeping carry bit in mind. All 3 cases (arr1 - exhausted, arr2 - not; arr2 - exhaused, arr1 - not; arr1 and arr2 still not exhausted) use divmod function to set the carry bit and item_to_add. On Intel CPUs this should happen in 1 instruction. The only difference is using both arrays if both are still not exhausted.&lt;/p&gt;
&lt;h3&gt;Iterative solution&lt;/h3&gt;
&lt;p&gt;Unrolls the recursive loop. Instead of creating a stack frame for each digit, add as many digits as possible before one of the arrays runs out, then handle the leftover digits from the longer array. In the case of arrays/numbers of the same length, there won't be any branch misprediction and we will fall through down to the return statement.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Wrapper to time each function call&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;newfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;startTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;startTime&lt;/span&gt;
        &lt;span class="n"&gt;time_as_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{:.6f}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_as_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newfunc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This takes the wrapped function, passes the original args, times how long it took to execute and returns a tuple of function return value and time_as_string.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@timeit&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For a fair comparison, both should have the same design and stack allocation strategy. Hence both iter_sum and recur_sum methods reverse the incoming arrays and return the result of the helper. The iterative method calculates everything in 1 stack frame. The recursive recur_sum_helper (by definition) creates a stack frame for each call. &lt;/p&gt;
&lt;p&gt;As both _sum methods prepare and pass reversed arrays into helper methods, the helper methods return the result array in the opposite order. Both _sum methods reverse the return arrays before returning.&lt;/p&gt;
&lt;h4&gt;Bug&lt;/h4&gt;
&lt;p&gt;In the first version of the recur_sum_helper and wrapper there was a bug - the recursive solution returned an array much longer than expected. This was the wrapper's fault, as was proven by running the methods without wrapping and stepping through it with pdb. &lt;/p&gt;
&lt;p&gt;The timeit wrapper method tooks the args and kwargs of the wrappee and kept them across runs. From the second interation onwards, the res array in the wrapped recur_sum_helper was kept inside the wrapper. Python variables are references, so after the res variable was created inside the scope of the wrapper, following &lt;code&gt;res.append&lt;/code&gt; calls grew the same res array as before. &lt;/p&gt;
&lt;p&gt;Adding&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;solved the problem by creating a new array.&lt;/p&gt;
&lt;h2&gt;Performance comparison&lt;/h2&gt;
&lt;p&gt;Using the script below, the wrapper described above, recursive and iterative solutions were benchmarked. The plots below show show time on the y-axis against the size of 2 input arrays on the x-axis. Green points - recursive times, red - iterative, blue star is the stack length of the array at which stack overflows. Catching stack overflow at runtime has to be done with a try/except loop, which breaks on RuntimeError. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;try_different_lengths_before_breaks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setrecursionlimit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;iter_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="c"&gt;# good test case, because there will be a carry bit over every step&lt;/span&gt;
        &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_recur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recur_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_recur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res_recur&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR - {} != {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;RuntimeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c"&gt;# stack limit exceeded&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_times&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;plot_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1005&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Size of input arrays&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Time to calculate sum (ms)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Comparing iterative vs recursive sum methods&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
    &lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recurs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;
    &lt;span class="n"&gt;point_normal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;point_stack_over&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;

    &lt;span class="c"&gt;# plot iterative times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_normal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# plot recursive times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;)[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;)[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_normal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;green&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# last point in recursive times is before stack overflow&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_stack_over&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sum_ints_plot.png&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;savefig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dpi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Saved plot as {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Stack depth limits&lt;/h3&gt;
&lt;p&gt;The first discovery was the limit to stack depth (it grows downards, contrary to common sense of adding things to the top of the stack). The default value is 1000 in Python 3.4 (use &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt; to look it up). Considering that recur_sum_helper is called inside recur_sum, which is wrapped and called inside __main__, we only have 996 stack frames for the recursive sum. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$$$&lt;/span&gt; &lt;span class="n"&gt;python3&lt;/span&gt;
&lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Oct&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt; &lt;span class="mi"&gt;2015&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;03&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GCC&lt;/span&gt; &lt;span class="mf"&gt;5.2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;20151010&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;linux&lt;/span&gt;
&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;credits&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;license&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getrecursionlimit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Plots&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_stack_standard.png" /&gt;&lt;/p&gt;
&lt;p&gt;The blue star marks a point of max_stack_depth. Generally, both scatter plots show linear increase in time with a sudden jump in recursive at ~900 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_stack_extra.png" /&gt;&lt;/p&gt;
&lt;p&gt;Using the same sys module, I could setrecursionlimit to a higher than default value and explore the difference between recursive and iterative solution on bigger input arrays. As expected, iterative kept winning and recursive suffered another drastic jump in times (~1600), thought the gradient remained linear.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, a simple problem was solved recursively and iteratively. Afterwards, both solutions were benchmarked and analysed in terms of their scalability. &lt;/p&gt;
&lt;p&gt;A recursive solution appears to purists and can be more readable in some cases like tree traversal. In this case, the recursive solution suffered. When combined with the lack of TCO and a relatively low default recursion depth limit value in the CPython interpreter, it proved unscalable and less efficient than iterative. Additionally, wrapping a recusive function introduced a bug, which was absent from the iterative solution.&lt;/p&gt;</summary><category term="algorithms"></category><category term="hackerrank"></category><category term="python"></category></entry><entry><title>Debugging hanging elpy on emacs</title><link href="/debugging-hanging-elpy-on-emacs.html" rel="alternate"></link><updated>2017-04-06T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-04-06:debugging-hanging-elpy-on-emacs.html</id><summary type="html">&lt;p&gt;I was hacking on a small python script, minding my own business when emacs stopped reacting to my keyboard input. I could still switch windows and work with another applications, but emacs hang up on me. &lt;/p&gt;
&lt;p&gt;Having spent a couple of hours stracing, &lt;a href="/drafts/stracing-emacs-part-1.html"&gt;grepping and awking emacs start-up syscalls&lt;/a&gt;, I was in the mood to debug some more. &lt;/p&gt;
&lt;p&gt;Attaching my shell to the pid of emacs (I usually only run 1 emacs instance, hence pgrep emacs). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo strace -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Returns the same error messages repeated.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ad nauseum.&lt;/p&gt;
&lt;p&gt;Using the combination of functional programming and bash magic, I nested one function call inside another to get the list of processes. &lt;code&gt;pgrep -P&lt;/code&gt; returns the PIDs of all child processes of a given PID. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ps -o pid,pcpu,comm -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;))&lt;/span&gt;
  PID %CPU COMMAND
&lt;span class="m"&gt;31513&lt;/span&gt;  97.4 python
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is only 1 child process, but it's eating up all the CPU time and killing my battery - it drained 13% in 10 minutes that I was googling and stracing. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This made emacs responsive again, so I examined the emacs &lt;em&gt;Messages&lt;/em&gt; buffer&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Wrote /home/petr_tik/Coding/misc/misc/dfs.py
error in process sentinel: elpy-rpc--default-error-callback: peculiar error: &amp;quot;terminated&amp;quot;
error in process sentinel: peculiar error: &amp;quot;terminated&amp;quot;
eldoc error: (file-error Writing to process bad file descriptor  *elpy-rpc [project:~/Coding/misc/misc/ python:/usr/bin/python]*)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/jorgenschaefer/elpy/issues/709"&gt;Here is a relevant GitHub issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Looks like it remains to be solved.&lt;/p&gt;</summary><category term="emacs"></category><category term="python"></category><category term="strace"></category></entry><entry><title>Puzzles in C++</title><link href="/puzzles-in-c.html" rel="alternate"></link><updated>2017-03-21T19:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-21:puzzles-in-c.html</id><summary type="html">&lt;p&gt;Notes on working with C++, my understanding of the small set of syntax features and data structures available. Might read like obvious or wrong set of assumptions to an experienced C++ engineer. Will keep updating with newer puzzles. &lt;/p&gt;
&lt;h2&gt;Namespaces&lt;/h2&gt;
&lt;p&gt;Define the set of functions, which are used during method name resolution. @jbcoe suggested to avoid it, as it can get messy with several conflicting namespaces.&lt;/p&gt;
&lt;p&gt;Adding this to the top of the file&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;defines where method names will be looked up, which would save 5 chars&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cout&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;instead of &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Data structures&lt;/h2&gt;
&lt;p&gt;Used stringstream object, which inherits from input_ and output_ streams. &lt;/p&gt;
&lt;h2&gt;Misc C++&lt;/h2&gt;
&lt;p&gt;Using clang++, -std=c++11 with awesome features like auto for type inference in for-loops&lt;/p&gt;
&lt;h2&gt;DNA counting puzzle&lt;/h2&gt;
&lt;p&gt;Given a DNA string, return the counts of each char (A, C, G, T). Initial solution - make a map with char as key and count &lt;int&gt; as value. Considering that the structure won't need to grow and we know the full range of characters that can appear, we can optimise. Instead, use an array and an enum to index into the cell in the array. Each value is started at 0 and as we iterate over the string, the value at the relevant index is incremented. That way, we can guarantee using one L1 cache line (4 ints = 16 bytes) and a buffer for the string. For further optimisation, we can implement a streaming buffer, if we are sure the string will only be used once. &lt;/p&gt;</summary><category term="cpp"></category><category term="puzzles"></category><category term="algorithms"></category></entry><entry><title>Notes on python's GC</title><link href="/notes-on-pythons-gc.html" rel="alternate"></link><updated>2017-03-07T23:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-07:notes-on-pythons-gc.html</id><summary type="html">&lt;p&gt;Notes on &lt;a href="https://www.youtube.com/watch?v=arxWaw-E8QQ"&gt;Memory Management in Python - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GC is a mechanism for managing memory at runtime. There are several methods including: mark-and-sweep and reference counting. Different language runtimes use different GC mechanisms, each asking for tradeoffs. eg. Java uses mark-and-sweep, which runs less frequently, but the sweep stage 'stops the world' and tidies up. I will be discussing CPython implementation and call it python for brevity (saving a character is very important). There are JPython and IronPython, which rely on JVM and CLR GC mechanisms respectively.&lt;/p&gt;
&lt;h2&gt;Mechanism&lt;/h2&gt;
&lt;p&gt;CPython uses reference counting with an optimisation to eliminate cyclic references, hence slower runtime. Similarly to pointers in C, the variable name is created on the stack and the pointer on the heap. Each created object has a field for storing its reference count - the number of variables that refer to the object. As soon as the refcount falls to 0, the GC collects/tidies up the object.&lt;/p&gt;
&lt;p&gt;Doing simple reference counting is prone to not deleting cyclically referenced objects. eg. If Object A refers to Object B and Object B to Object A, they will never get collected using simple reference counting (both will always have a ref count of at least 1). &lt;/p&gt;
&lt;h3&gt;Difference between py2 and py3 gc.&lt;/h3&gt;
&lt;p&gt;Python3 has a get_stats() method, which returns a list of dictionaries containing per-generation statistics. &lt;/p&gt;
&lt;h3&gt;Interacting&lt;/h3&gt;
&lt;p&gt;THere is a builtin module called gc, which allows you to enable, disable or run GC at any point in your programme. Some explanations that I read say you can change the number of generations, yet I can't find a method for that. The gc.set_threshold() command throws a "TypeError:  takes at most 3 arguments (4 given)". &lt;/p&gt;
&lt;h2&gt;Optimisations/heuristics&lt;/h2&gt;
&lt;h3&gt;Generations&lt;/h3&gt;
&lt;p&gt;All objects are split into 3 exclusive generations. The idea behind it is that objects won't live long, so younger generations are GC'ed more often than older generations. Generation 0 is where the newly created object lives, until it's spent enough time to be promoted. &lt;/p&gt;
&lt;h3&gt;Global value reuse&lt;/h3&gt;
&lt;p&gt;When a new variable (reference) is created, the python runtime checks if an object with such a value already exists. If it does, the new variable doesn't create a reference, instead it increases the refcount of int_object with value 10 to 2 as below. This works either when the object a new object is created or a primitive object's value is changed to match the value of an already existing object.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python creates an int object on the heap. If a new variable is created on the stack and assigned to a value, python sets up a reference between the new variable and the already existing object. &lt;/p&gt;</summary><category term="python"></category><category term="gc"></category><category term="memory"></category></entry><entry><title>CI for Solent-eng</title><link href="/ci-for-solent-eng.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:ci-for-solent-eng.html</id><summary type="html">&lt;p&gt;Spent the day working on a plan to build custom CI pipeline for &lt;a href="https://github.com/solent-eng/solent"&gt;solent&lt;/a&gt;. The design encourages and relies on GitHub-workflow using Pull Requests for all changes - even small ones made by the creator/admin. Will run test suites on different VMs and only allow PR to be merged, if all tests pass. Adding a new VM (for BSD, OSX, minix or other platform) should be: 1) easy, 2) independent of others and independent of the code on master.&lt;/p&gt;
&lt;h2&gt;Pull Request workflow&lt;/h2&gt;
&lt;p&gt;As an OSS project developed in 2017, Solent-eng should have a contributor-friendly way of reviewing issues, pushing changes and testing code. Using the GitHub webhook API, an event loop will notify the master slave of all changes to any Pull Requests (new or existing). This combined with the repo settings preventing from direct pushes to master will make everyone's commits go through the CI suite. This will also apply for the admin, as he is equally human and can make mistakes. Such culture of testing early, often and meritocratically, will help maintain the quality of code with hopefully few regressions. &lt;/p&gt;
&lt;h2&gt;CI master server&lt;/h2&gt;
&lt;p&gt;Lives on a VM in the cloud. In charge of listening to GitHub hooks, keeps a queue of jobs. Starts and monitors OS-specific VMs that run the test suite as of a given commit. Communicates the outcome of all test runners to the GitHub commit's status API.&lt;/p&gt;
&lt;h2&gt;GitHub webhook&lt;/h2&gt;
&lt;p&gt;A server will listen to events from the GitHub webhook, which in their payload will carry the refs and commit hashes of the PR. Initially, we will consider 3 scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New pull request&lt;/li&gt;
&lt;li&gt;Changes to a currently open PR&lt;/li&gt;
&lt;li&gt;Closed and merged a Pull Request&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;New PR or changes to current PR&lt;/h3&gt;
&lt;p&gt;First prototype - tear down current VMs of out-of-date commit hash. Start a new set of VMs with the new commit.&lt;/p&gt;
&lt;p&gt;Long-term plan: add the new commit hash to the job queue. Run all suites for all commits. &lt;/p&gt;
&lt;h3&gt;Closed and merged a Pull Request&lt;/h3&gt;
&lt;p&gt;Each test VM, if test suite exits with 0 errors, should build its executable. The CI master will tell each VM to upload the artefact to a location. TODO: hardwire the address inside the VM test runner or pass it as part of the request from the master.&lt;/p&gt;
&lt;h2&gt;Test suite VMs&lt;/h2&gt;
&lt;p&gt;Plans to support linux, BSD, OSX and Windows. All test suites will be run in VMs either in the cloud or on-premises. If tests fail, logs of terminal output should be forwarded to master. TODO: decide how CI-master will show it to GitHub users.&lt;/p&gt;</summary><category term="python"></category><category term="solent"></category><category term="ci"></category></entry><entry><title>Unexpected bfs</title><link href="/unexpected-bfs.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:unexpected-bfs.html</id><summary type="html">&lt;p&gt;This &lt;a href="https://www.hackerrank.com/challenges/candies"&gt;puzzle&lt;/a&gt; is in the DP section of HackerRank. With DP, you expect a recursive solution is expected, which is less memory efficient. Therefore, you should find a way to memoize/cache results of previous calculations to make it pass. &lt;/p&gt;
&lt;h2&gt;Problem statement:&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Given an array of students&amp;#39; grades (ints) in the same order as they sit. Return the minimal number of candies all students receive, such that:
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;out of 2 adjacent students, the one with a higher grade receives more candy&lt;/li&gt;
&lt;li&gt;each student receives at least 1 piece of candy&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Plot twist&lt;/h3&gt;
&lt;p&gt;Alternatively, you can look at the problem as a graph theory problem. &lt;/p&gt;
&lt;p&gt;Represent each student as a node on a plane. Among adjacent nodes, draw directed edges from the node with a lower grade to the node with a higher grade. All the nodes without incoming edges aren't greater than their neighbours (equal grades means you can give less candy), so they will receive the minimum amount - 1. Now start several breadth-first searches from each of the nodes without incoming edges (they will be the local start points). Visit node and increment the value at its index in the candies array. Differently to normal breadth-first search, you don't need to keep track of previously visited nodes and you can revisit them to increment the counter. In case you have a peak around a point 8 (index = 3) eg&lt;/p&gt;
&lt;p&gt;grades
1 2 4 8 6 5 3 2 1&lt;/p&gt;
&lt;p&gt;candies (illegal) - if you don't revisit nodes to update counter. 
1 2 3 4 5 4 3 2 1 &lt;/p&gt;
&lt;p&gt;candies (solution)
1 2 3 6 5 4 3 2 1&lt;/p&gt;
&lt;h3&gt;Complexity&lt;/h3&gt;
&lt;p&gt;The prepare_for_bfs method takes linear O(n) time and bfs takes maximum O(V + E)&lt;/p&gt;
&lt;p&gt;The code is &lt;a href="https://github.com/petr-tik/misc/blob/master/candies.py"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you see a problem in description or the code, please open issues, send PRs&lt;/p&gt;</summary><category term="python"></category><category term="algorithms"></category><category term="hackerrank"></category></entry><entry><title>Getting clojure with Lisp</title><link href="/getting-clojure-with-lisp.html" rel="alternate"></link><updated>2016-02-20T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2016-02-20:getting-clojure-with-lisp.html</id><summary type="html">&lt;p&gt;I have spent the weekend reading and getting my head around Clojure and here are my first thoughts.&lt;/p&gt;
&lt;p&gt;It's definitely a great exercise and even if I will never get to write a single line of code in a functional language in my life, I will be more confident using map, filter and reduce in python. &lt;/p&gt;
&lt;p&gt;Adopting the immutable data approach, makes me really concentrate on the quality and good compositionality of the functions, where I really think through how to make a series of pure functions, whose output will feed into the next one's input well. WHile REPL-based development is helpful to try defn functions on the fly to experiment, my python background is annoyed that I cannot just print the state of the programme at every step: 
i) pure functions are stateless
ii) pure functions have no side effect like printing to the stdout&lt;/p&gt;
&lt;p&gt;As this is an exercise in thinking and writing pure functions, printing to stdout is betraying the clojure way and would involve a helper function that needs to wrap each function and print the arguments and output. &lt;/p&gt;
&lt;p&gt;Going forward, I've been told 4Clojure is a good source of problems and the TDD framework is very thorough. Another upside of pure functions I hope to experience soon is the ease of unit testing them. If you write all helper functions and main the UNIX way, you should be able to test each of them separately and when composed with easy input. &lt;/p&gt;
&lt;p&gt;A good exercise, which lends itself nicely to Clojure is checking if a given word and any word from a vector of words have are anagrams. &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagram?&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes 2 words - returns True if they are anagrams, false otherwise&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;word1&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;true&lt;/span&gt;
        &lt;span class="nv"&gt;false&lt;/span&gt;
        &lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagrams&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes a target word and a vector of words &lt;/span&gt;
&lt;span class="s"&gt;Returns a list of anagrams of the target from the vector&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;anagram?&lt;/span&gt; &lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="clojure"></category></entry></feed>