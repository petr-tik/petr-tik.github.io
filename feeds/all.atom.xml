<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>My blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2017-04-12T23:20:00+01:00</updated><entry><title>Grokking dfs and backtracking on a Graph (sort of)</title><link href="/grokking-dfs-and-backtracking-on-a-graph-sort-of.html" rel="alternate"></link><updated>2017-04-12T23:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-04-12:grokking-dfs-and-backtracking-on-a-graph-sort-of.html</id><summary type="html">&lt;h2&gt;Problem statement&lt;/h2&gt;
&lt;p&gt;Given:
  * an array of ints (default - 6)
  * array of operations (default - addition, multiplication, division, deduction) 
  * a target int value.&lt;/p&gt;
&lt;p&gt;Return True, if it's possible to combine all numbers in the array with operations to result in target value&lt;/p&gt;
&lt;h2&gt;Brute force&lt;/h2&gt;
&lt;p&gt;Generate all combinations of operations (4**5 = 1024) and calculate them&lt;/p&gt;
&lt;h2&gt;First attempt&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results_so_far&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;results_so_far&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;results_so_far&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;results_so_far&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arr_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;any&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;results_so_far&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;results_so_far&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arr_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="algorithms"></category><category term="graphs"></category><category term="dfs"></category></entry><entry><title>Debugging hanging elpy on emacs</title><link href="/debugging-hanging-elpy-on-emacs.html" rel="alternate"></link><updated>2017-04-06T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-04-06:debugging-hanging-elpy-on-emacs.html</id><summary type="html">&lt;p&gt;I was hacking on a small python script, minding my own business when emacs stopped reacting to my keyboard input. I could still switch windows and work with another applications, but emacs hang up on me. &lt;/p&gt;
&lt;p&gt;Having spent a couple of hours stracing, grepping and awking emacs start-up syscalls, I was in the mood to debug some more. &lt;/p&gt;
&lt;p&gt;Attaching my shell to the pid of emacs (I usually only run 1 emacs instance, hence pgrep emacs). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo strace -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Returns the same error messages repeated.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ad nauseum.&lt;/p&gt;
&lt;p&gt;Using the combination of functional programming and bash magic, I nested one function call inside another to get the list of processes. &lt;code&gt;pgrep -P&lt;/code&gt; returns the PIDs of all child processes of a given PID. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ps -o pid,pcpu,comm -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;))&lt;/span&gt;
  PID %CPU COMMAND
&lt;span class="m"&gt;31513&lt;/span&gt;  97.4 python
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is only 1 child process, but it's eating up all the CPU time and killing my battery - it drained 13% in 10 minutes that I was googling and stracing. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This made emacs responsive again, so I examined the emacs &lt;em&gt;Messages&lt;/em&gt; buffer&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Wrote /home/petr_tik/Coding/misc/misc/dfs.py
error in process sentinel: elpy-rpc--default-error-callback: peculiar error: &amp;quot;terminated&amp;quot;
error in process sentinel: peculiar error: &amp;quot;terminated&amp;quot;
eldoc error: (file-error Writing to process bad file descriptor  *elpy-rpc [project:~/Coding/misc/misc/ python:/usr/bin/python]*)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/jorgenschaefer/elpy/issues/709"&gt;Here is a relevant GitHub issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Looks like it remains to be solved.&lt;/p&gt;</summary><category term="emacs"></category><category term="python"></category><category term="strace"></category></entry><entry><title>Stracing emacs. Part 1</title><link href="/stracing-emacs-part-1.html" rel="alternate"></link><updated>2017-03-28T23:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-28:stracing-emacs-part-1.html</id><summary type="html">&lt;p&gt;In this series of posts, I investigate and report Emacs start-up procedure and how to optimise it. Emacs is a beautiful OS with a built-in ELisp interpreter and some text editing capabilities. &lt;/p&gt;
&lt;p&gt;I used strace by examining the start up of emacs. &lt;a href="https://github.com/petr-tik/emacs-config"&gt;My emacs config is different&lt;/a&gt; and will be compared to a vanilla emacs start-up. For each syscall I investigated and summarised return values, their frequency to find out how I can improve it. &lt;/p&gt;
&lt;p&gt;I ran the command below, waited until emacs was fully loaded and quit it. -C combines -c with normal output i.e. it printed each syscall, while the process was live and finished the file with the summary table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;strace -C -o emacs_strace_output emacs
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Format&lt;/h2&gt;
&lt;p&gt;I will choose different parameters by which I will choose syscalls to analyse. Then I use the manpage, my favourite search engine (CrouchCrouchWalk) to write up my understanding of the processes.&lt;/p&gt;
&lt;h2&gt;Top 10 by time&lt;/h2&gt;
&lt;p&gt;From the &lt;code&gt;man strace | grep -A 4 sort&lt;/code&gt; page - Strace can sort by time, calls, name, and nothing (default is time). For data consistency, I will use the same output file and awk magic.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; tail -n &lt;span class="m"&gt;69&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; head -n 12
% &lt;span class="nb"&gt;time     &lt;/span&gt;seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 27.05    0.000109           &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;18973&lt;/span&gt;     &lt;span class="m"&gt;17979&lt;/span&gt; open
 23.33    0.000094           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;5192&lt;/span&gt;      &lt;span class="m"&gt;3609&lt;/span&gt; recvmsg
 15.88    0.000064           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;2432&lt;/span&gt;           munmap
 13.65    0.000055           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;3179&lt;/span&gt;           poll
  8.44    0.000034           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;3208&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt;
&lt;span class="nb"&gt;  &lt;/span&gt;6.45    0.000026           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;1610&lt;/span&gt;           writev
  2.73    0.000011           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;5127&lt;/span&gt;           lseek
  2.48    0.000010           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;1005&lt;/span&gt;           close
  0.00    0.000000           &lt;span class="m"&gt;0&lt;/span&gt;        &lt;span class="m"&gt;14&lt;/span&gt;           write
  0.00    0.000000           &lt;span class="m"&gt;0&lt;/span&gt;       &lt;span class="m"&gt;605&lt;/span&gt;       &lt;span class="m"&gt;119&lt;/span&gt; stat
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;open&lt;/h2&gt;
&lt;p&gt;Syscall that usually takes a pointer to const array of chars for pathname and an int for flags. Flags carry information about access modes (read-only, write-only or read-n-write) and file status flags. &lt;/p&gt;
&lt;p&gt;Returns an int that is a file descriptor (non-negative int), which other syscalls in the process will use to access the same file. There is no need to randomly assign fd numbers, so they are given out in ascending order. &lt;/p&gt;
&lt;h4&gt;Errors:&lt;/h4&gt;
&lt;p&gt;Used the magic of grep and awk to extract, count and summarise the number of times each return value (including errors) occured.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep &lt;span class="s2"&gt;&amp;quot;^open&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;)&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;grep "open(" emacs_strace_output&lt;/code&gt;- returns the lines with open syscall trace. "^open(" guarantees that we only examine lines starting with "open"&lt;/p&gt;
&lt;p&gt;&lt;code&gt;awk 'BEGIN { FS=")"} { print $2 }'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Takes the lines and prints column 2 after the ")" separator, which comes at the end of the open syscall. Return values come in different formats&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; -1 ENOENT &lt;span class="o"&gt;(&lt;/span&gt;No such file or directory&lt;span class="o"&gt;)&lt;/span&gt;
 8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we need another awk with a different FS (field separator) variable.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;awk '{ print $2}'&lt;/code&gt; - which uses the default field separator " " and prints the second column, which will be the return value.&lt;/p&gt;
&lt;p&gt;Successful return is a positive int file descriptor, a negative return value can be looked up in the man page for open. Sorting arranges values return values in order, so &lt;code&gt;uniq -c&lt;/code&gt; can summarise and return the count of each value followed by the value. &lt;code&gt;sort -nr&lt;/code&gt; sorts it by numeric value in descending order of counts. &lt;/p&gt;
&lt;p&gt;Below is the end bash one-liner and the resulting table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;count   ret_val&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^open(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;)&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
count   ret_val
  &lt;span class="m"&gt;17979&lt;/span&gt; -1
    &lt;span class="m"&gt;624&lt;/span&gt; 7
    &lt;span class="m"&gt;131&lt;/span&gt; 8
     &lt;span class="m"&gt;86&lt;/span&gt; 3
     &lt;span class="m"&gt;83&lt;/span&gt; 9
     &lt;span class="m"&gt;20&lt;/span&gt; 6
     &lt;span class="m"&gt;15&lt;/span&gt; 4
     &lt;span class="m"&gt;11&lt;/span&gt; 11
     &lt;span class="m"&gt;10&lt;/span&gt; 5
      &lt;span class="m"&gt;6&lt;/span&gt; 10
      &lt;span class="m"&gt;5&lt;/span&gt; 14
      &lt;span class="m"&gt;2&lt;/span&gt; 12
      &lt;span class="m"&gt;1&lt;/span&gt; 13
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As seen in the summary, 17979 open syscalls returned the error value -1, which stands for ENOINT - no such file or directory. Judging by the greatest return value, not more than 14 files are open simultaneously during the start-up process. 18973 - 17979 = 994 and there are 1005 succesful &lt;code&gt;close&lt;/code&gt; syscalls, so 11 times an fd must have been closed and reused. &lt;/p&gt;
&lt;p&gt;Looking at each open syscall with return value 7. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;grep &lt;span class="s2"&gt;&amp;quot;^open&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;\&amp;quot;| &amp;quot; } { print $2,$6 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot; 7&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $1 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
     &lt;span class="m"&gt;23&lt;/span&gt; /usr/share/icons/default/index.theme
     &lt;span class="m"&gt;12&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/dash-20161121.55/dash-autoloads.el
      &lt;span class="m"&gt;8&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/s-20140714.707/s-autoloads.el
      &lt;span class="m"&gt;6&lt;/span&gt; /usr/share/emacs/24.5/lisp/emacs-lisp/cl-seq.elc
      &lt;span class="m"&gt;6&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/json-snatcher-20150511.2047/json-snatcher-autoloads.el
      &lt;span class="m"&gt;6&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/json-reformat-20160212.53/json-reformat-autoloads.el
      ...
      more filespaths
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shows that several files are repeatedly opened on the same file descriptor. &lt;/p&gt;
&lt;p&gt;Looking at the usr/share/icons/default/index.theme&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep -n &lt;span class="s2"&gt;&amp;quot;usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt; emacs_strace_output 
1530:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 6
3412:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
3446:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
    ...
    more filespaths
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;we take the line numbers where /usr/share/icons/default/index.theme appears and examine a typical case of such a syscall. The first line it is opened under fd 6, so we take the needed number of lines (head for first 1549 lines, out of which we will need the last 20). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;head -n &lt;span class="m"&gt;1535&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 6
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 6
fstat&lt;span class="o"&gt;(&lt;/span&gt;6, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;32, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 4096, PROT_READ&lt;span class="p"&gt;|&lt;/span&gt;PROT_WRITE, MAP_PRIVATE&lt;span class="p"&gt;|&lt;/span&gt;MAP_ANONYMOUS, -1, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;6, &lt;span class="s2"&gt;&amp;quot;[Icon Theme]\nInherits=DMZ-White\n&amp;quot;&lt;/span&gt;, 4096&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 32
close&lt;span class="o"&gt;(&lt;/span&gt;6&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 4096&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;after opening the file, emacs runs fstat on the given file descriptor. After that, 4096 bytes of memory is mapped.&lt;/p&gt;
&lt;h2&gt;recvmsg&lt;/h2&gt;
&lt;p&gt;syscall to receive messages from a socket. Came from 4.4BSD (sockets were a BSD invention).&lt;/p&gt;
&lt;p&gt;Input is a socket file descriptor int, pointer to the struct of type msghdr and int for flags. If succesful, they return the length of the receied message. -1 is the error ret value. Summary table shows &amp;gt;3000 error returns, which are investigated below.&lt;/p&gt;
&lt;p&gt;recvmsg uses the pointer to the msghdr struct to minimise the number of arguments. &lt;/p&gt;
&lt;h4&gt;Errors:&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;freq    ret_val&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^recvmsg(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;) &amp;quot;} { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39; { print $2 } &amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
freq    ret_val
   &lt;span class="m"&gt;3609&lt;/span&gt; -1
   &lt;span class="m"&gt;1369&lt;/span&gt; 32
     &lt;span class="m"&gt;97&lt;/span&gt; 224
     &lt;span class="m"&gt;44&lt;/span&gt; 48
     &lt;span class="m"&gt;17&lt;/span&gt; 64
     &lt;span class="m"&gt;17&lt;/span&gt; 40
      &lt;span class="m"&gt;8&lt;/span&gt; 96
      &lt;span class="m"&gt;5&lt;/span&gt; 36
      &lt;span class="m"&gt;4&lt;/span&gt; 128
      &lt;span class="m"&gt;3&lt;/span&gt; 4096
      &lt;span class="m"&gt;3&lt;/span&gt; 1360
      &lt;span class="m"&gt;2&lt;/span&gt; 76
      &lt;span class="m"&gt;2&lt;/span&gt; 160
      &lt;span class="m"&gt;1&lt;/span&gt; 896
      &lt;span class="m"&gt;1&lt;/span&gt; 832
      &lt;span class="m"&gt;1&lt;/span&gt; 56
      &lt;span class="m"&gt;1&lt;/span&gt; 336
      &lt;span class="m"&gt;1&lt;/span&gt; 3348
      &lt;span class="m"&gt;1&lt;/span&gt; 3316
      &lt;span class="m"&gt;1&lt;/span&gt; 268
      &lt;span class="m"&gt;1&lt;/span&gt; 256
      &lt;span class="m"&gt;1&lt;/span&gt; 208
      &lt;span class="m"&gt;1&lt;/span&gt; 1948
      &lt;span class="m"&gt;1&lt;/span&gt; 1236
      &lt;span class="m"&gt;1&lt;/span&gt; 1188
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The number of -1 matches the one 3609 in the summary table confirming that the bash oneliner was correct. The return value is usually the number of bytes read from the socket, which we can expect to be a power of 2. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;   freq socket_descriptor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^recvmsg(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; grep -v &lt;span class="s2"&gt;&amp;quot;= -1&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;\\\\(+|,+&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
   freq socket_descriptor
   &lt;span class="m"&gt;1583&lt;/span&gt; 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;grep for all recvmsg syscalls, which don't return a -1 error value. NB "\\(" escapes the bracket character and returns the first argument of each recvmsg syscall invocation. uniq -c returns the frequncy for each value. It turned out that emacs listens on only one socket file descriptor (happens to be number 5). Further inspection didn't give too much information.&lt;/p&gt;
&lt;h2&gt;munmap&lt;/h2&gt;
&lt;p&gt;Evil brother of mmap (more info below), which deletes the mappings for the specified address. After that, all references to addresses in that range (addr + length) are invalidated. NB - closing a file descriptor doesn't unmap the region, which means for security you want to close fds and then unmap the region. &lt;/p&gt;
&lt;p&gt;Input:
    pointer of type void to address 
    size_t length&lt;/p&gt;
&lt;p&gt;Returns:
    0 if succesful
    -1 on failure&lt;/p&gt;
&lt;p&gt;mmap - takes more parameters like flags and protection flags, which determine the access rights to those pages. &lt;/p&gt;
&lt;p&gt;Examining output. No errors, just invocation patterns. &lt;/p&gt;
&lt;h5&gt;bash command&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,|\\\\)&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;grep for munmap at the beginning of the line - as before&lt;/li&gt;
&lt;li&gt;awk with 2 field separators comma "," and closing bracket ")"&lt;/li&gt;
&lt;li&gt;print the second column, which will be the size_t var for length of region to unmap. &lt;/li&gt;
&lt;li&gt;sort all occurences of each size_t&lt;/li&gt;
&lt;li&gt;count each uniq value and return a table of counts&lt;/li&gt;
&lt;li&gt;sort the table in descending order&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;   freq  size_t&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,|\\\\)&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
   freq  size_t
   &lt;span class="m"&gt;2067&lt;/span&gt;  69632
    &lt;span class="m"&gt;265&lt;/span&gt;  4096
     &lt;span class="m"&gt;84&lt;/span&gt;  790528
      &lt;span class="m"&gt;5&lt;/span&gt;  117548
      &lt;span class="m"&gt;2&lt;/span&gt;  565248
      &lt;span class="m"&gt;2&lt;/span&gt;  245760
      &lt;span class="m"&gt;2&lt;/span&gt;  2339
      &lt;span class="m"&gt;1&lt;/span&gt;  99000
      &lt;span class="m"&gt;1&lt;/span&gt;  606208
      &lt;span class="m"&gt;1&lt;/span&gt;  475136
      &lt;span class="m"&gt;1&lt;/span&gt;  424408
      &lt;span class="m"&gt;1&lt;/span&gt;  122880
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Funny values of size_t. I found 2339 an interesting value for size_t and deciding to dig into it. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -n &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;, 2339&amp;quot;&lt;/span&gt;
1016:munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
1023:munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;returns the matched lines with the line number from the original strace_file. So I made a head and tail pipe, which opens the relevant region of the strace output. &lt;a href="https://www.youtube.com/watch?v=Zk5Il6KQrd8"&gt;oh that's a bingo!&lt;/a&gt; - it happens to be the region, when /etc/passwd was opened. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; head -n &lt;span class="m"&gt;1024&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 14
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/etc/passwd&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 4
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 0, SEEK_CUR&lt;span class="o"&gt;)&lt;/span&gt;                   &lt;span class="o"&gt;=&lt;/span&gt; 0
fstat&lt;span class="o"&gt;(&lt;/span&gt;4, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2339, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 2339, PROT_READ, MAP_SHARED, 4, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 2339, SEEK_SET&lt;span class="o"&gt;)&lt;/span&gt;                &lt;span class="o"&gt;=&lt;/span&gt; 2339
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
close&lt;span class="o"&gt;(&lt;/span&gt;4&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/etc/passwd&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 4
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 0, SEEK_CUR&lt;span class="o"&gt;)&lt;/span&gt;                   &lt;span class="o"&gt;=&lt;/span&gt; 0
fstat&lt;span class="o"&gt;(&lt;/span&gt;4, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2339, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 2339, PROT_READ, MAP_SHARED, 4, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 2339, SEEK_SET&lt;span class="o"&gt;)&lt;/span&gt;                &lt;span class="o"&gt;=&lt;/span&gt; 2339
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
close&lt;span class="o"&gt;(&lt;/span&gt;4&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;poll&lt;/h2&gt;
&lt;p&gt;Similar to select syscall, only newer. ppoll is newer still. Waits for one of a set of fds to come available for IO operations. &lt;/p&gt;
&lt;p&gt;Input:
    pointer to struct of type pollfd - carries the filedescriptor int and requested events
    nfds_t - number of file descriptors to watch
    timeout - milliseconds the syscall can block while waiting for an fd to be ready. It can be interrupted by a signal hanlder. You can set an infinite timeout with a negative value.&lt;/p&gt;
&lt;p&gt;Returns:
    if succesful - positive number of structures with several returned event fields. 
    0 if timed out and/or no fds became ready
    -1 on error&lt;/p&gt;
&lt;h4&gt;Inspecting&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^poll(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot; =&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot; |=|,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
     &lt;span class="m"&gt;61&lt;/span&gt; 0
   &lt;span class="m"&gt;3118&lt;/span&gt; 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;61 poll calls timed out. &lt;/p&gt;
&lt;h2&gt;read&lt;/h2&gt;
&lt;p&gt;Tries to read bytes from a given file descriptor into a buffer. &lt;/p&gt;
&lt;p&gt;Gotcha: if count &amp;gt; SSIZE_MAX, the result is unspecified.&lt;/p&gt;
&lt;p&gt;Input:
    file descriptor 
    pointer to buf
    count of type size_t &lt;/p&gt;
&lt;p&gt;Returns:
    if successfully read - returns int number of read bytes, by which the file position is also advanced. The return value may be less than the count (bytes that were requested to read), if a signal interrupts the syscall or we reach EOF. 
    on error, -1 is set to errno. Unspecified if the file position value changes. &lt;/p&gt;
&lt;p&gt;The only error happens when we try to read from the paredit.elc file descriptor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep -n &lt;span class="s2"&gt;&amp;quot;^open(.* = 7\|^read(.* = -1&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 2
50481:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/home/petr_tik/.emacs.d/elpa/paredit-20140128.1248/paredit.elc&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
51237:read&lt;span class="o"&gt;(&lt;/span&gt;7, 0x7fffe3761b80, 16&lt;span class="o"&gt;)&lt;/span&gt;             &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;writev&lt;/h2&gt;
&lt;p&gt;Writes given buffers of data to a given file descriptor. Similar to write, but sequentially goes through all the buffers. &lt;/p&gt;
&lt;p&gt;Returns:
    number of bytes written.
    -1 if error&lt;/p&gt;
&lt;h4&gt;Inspecting&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^writev(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;\\\\(|,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
   &lt;span class="m"&gt;1610&lt;/span&gt; 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All writev syscalls take file descriptor 5. Is it a coincidence?&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;lseek&lt;/h2&gt;
&lt;p&gt;Given a file descritpor, offset and whence parameters, reposition the offset on the file descriptor. It can move the offset beyond the file size. &lt;/p&gt;
&lt;p&gt;Returns: resulting offset location (in bytes) from the beginning of the file.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;close&lt;/h2&gt;
&lt;p&gt;Does what it says on the tin. Closes a given file desciptor, which allows the int value to be reused. It can return an error and you better check the return value to avoid nasty bugs. It can be interrupted by a signal, in which case it doesn't close the file. Prone to race conditions.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;write&lt;/h2&gt;
&lt;p&gt;writes to a given file descriptor.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;stat&lt;/h2&gt;
&lt;p&gt;Like the terminal stat command, returns the status of a file at a given pathname.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;Confirming that the bash one-liner catches all the errors.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^stat(.* = -1&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; wc -l
119
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now print the list of pathnames that return errors and the ret_values.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^stat(.* = -&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;\\\\(\&amp;quot;|\&amp;quot;,| =| &amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; { print $2, $6 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Most errors have the value of -1, which according to error section in the &lt;code&gt;man 2 stat&lt;/code&gt; is ENOENT A  component  of  pathname  does  not exist, or pathname is an empty string.&lt;/p&gt;</summary><category term="linux"></category><category term="tracing"></category><category term="emacs"></category></entry><entry><title>Notes on python's GC</title><link href="/notes-on-pythons-gc.html" rel="alternate"></link><updated>2017-03-07T23:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-07:notes-on-pythons-gc.html</id><summary type="html">&lt;p&gt;Notes on &lt;a href="https://www.youtube.com/watch?v=arxWaw-E8QQ"&gt;Memory Management in Python - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GC is a mechanism for managing memory at runtime. There are several methods including: mark-and-sweep and reference counting. Different language runtimes use different GC mechanisms, each asking for tradeoffs. eg. Java uses mark-and-sweep, which runs less frequently, but the sweep stage 'stops the world' and tidies up. I will be discussing CPython implementation and call it python for brevity (saving a character is very important). There are JPython and IronPython, which rely on JVM and CLR GC mechanisms respectively.&lt;/p&gt;
&lt;h2&gt;Mechanism&lt;/h2&gt;
&lt;p&gt;CPython uses reference counting with an optimisation to eliminate cyclic references, hence slower runtime. Similarly to pointers in C, the variable name is created on the stack and the pointer on the heap. Each created object has a field for storing its reference count - the number of variables that refer to the object. As soon as the refcount falls to 0, the GC collects/tidies up the object.&lt;/p&gt;
&lt;p&gt;Doing simple reference counting is prone to not deleting cyclically referenced objects. eg. If Object A refers to Object B and Object B to Object A, they will never get collected using simple reference counting (both will always have a ref count of at least 1). &lt;/p&gt;
&lt;h3&gt;Difference between py2 and py3 gc.&lt;/h3&gt;
&lt;p&gt;Python3 has a get_stats() method, which returns a list of dictionaries containing per-generation statistics. &lt;/p&gt;
&lt;h3&gt;Interacting&lt;/h3&gt;
&lt;p&gt;THere is a builtin module called gc, which allows you to enable, disable or run GC at any point in your programme. Some explanations that I read say you can change the number of generations, yet I can't find a method for that. The gc.set_threshold() command throws a "TypeError:  takes at most 3 arguments (4 given)". &lt;/p&gt;
&lt;h2&gt;Optimisations/heuristics&lt;/h2&gt;
&lt;h3&gt;Generations&lt;/h3&gt;
&lt;p&gt;All objects are split into 3 exclusive generations. The idea behind it is that objects won't live long, so younger generations are GC'ed more often than older generations. Generation 0 is where the newly created object lives, until it's spent enough time to be promoted. &lt;/p&gt;
&lt;h3&gt;Global value reuse&lt;/h3&gt;
&lt;p&gt;When a new variable (reference) is created, the python runtime checks if an object with such a value already exists. If it does, the new variable doesn't create a reference, instead it increases the refcount of int_object with value 10 to 2 as below. This works either when the object a new object is created or a primitive object's value is changed to match the value of an already existing object.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python creates an int object on the heap. If a new variable is created on the stack and assigned to a value, python sets up a reference between the new variable and the already existing object. &lt;/p&gt;</summary><category term="python"></category><category term="gc"></category><category term="memory"></category></entry><entry><title>CI for Solent-eng</title><link href="/ci-for-solent-eng.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:ci-for-solent-eng.html</id><summary type="html">&lt;p&gt;Spent the day working on a plan to build custom CI pipeline for &lt;a href="https://github.com/solent-eng/solent"&gt;solent&lt;/a&gt;. The design encourages and relies on GitHub-workflow using Pull Requests for all changes - even small ones made by the creator/admin. Will run test suites on different VMs and only allow PR to be merged, if all tests pass. Adding a new VM (for BSD, OSX, minix or other platform) should be: 1) easy, 2) independent of others and independent of the code on master.&lt;/p&gt;
&lt;h2&gt;Pull Request workflow&lt;/h2&gt;
&lt;p&gt;As an OSS project developed in 2017, Solent-eng should have a contributor-friendly way of reviewing issues, pushing changes and testing code. Using the GitHub webhook API, an event loop will notify the master slave of all changes to any Pull Requests (new or existing). This combined with the repo settings preventing from direct pushes to master will make everyone's commits go through the CI suite. This will also apply for the admin, as he is equally human and can make mistakes. Such culture of testing early, often and meritocratically, will help maintain the quality of code with hopefully few regressions. &lt;/p&gt;
&lt;h2&gt;CI master server&lt;/h2&gt;
&lt;p&gt;Lives on a VM in the cloud. In charge of listening to GitHub hooks, keeps a queue of jobs. Starts and monitors OS-specific VMs that run the test suite as of a given commit. Communicates the outcome of all test runners to the GitHub commit's status API.&lt;/p&gt;
&lt;h2&gt;GitHub webhook&lt;/h2&gt;
&lt;p&gt;A server will listen to events from the GitHub webhook, which in their payload will carry the refs and commit hashes of the PR. Initially, we will consider 3 scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New pull request&lt;/li&gt;
&lt;li&gt;Changes to a currently open PR&lt;/li&gt;
&lt;li&gt;Closed and merged a Pull Request&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;New PR or changes to current PR&lt;/h3&gt;
&lt;p&gt;First prototype - tear down current VMs of out-of-date commit hash. Start a new set of VMs with the new commit.&lt;/p&gt;
&lt;p&gt;Long-term plan: add the new commit hash to the job queue. Run all suites for all commits. &lt;/p&gt;
&lt;h3&gt;Closed and merged a Pull Request&lt;/h3&gt;
&lt;p&gt;Each test VM, if test suite exits with 0 errors, should build its executable. The CI master will tell each VM to upload the artefact to a location. TODO: hardwire the address inside the VM test runner or pass it as part of the request from the master.&lt;/p&gt;
&lt;h2&gt;Test suite VMs&lt;/h2&gt;
&lt;p&gt;Plans to support linux, BSD, OSX and Windows. All test suites will be run in VMs either in the cloud or on-premises. If tests fail, logs of terminal output should be forwarded to master. TODO: decide how CI-master will show it to GitHub users.&lt;/p&gt;</summary><category term="python"></category><category term="solent"></category><category term="ci"></category></entry><entry><title>Unexpected bfs</title><link href="/unexpected-bfs.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:unexpected-bfs.html</id><summary type="html">&lt;p&gt;This &lt;a href="https://www.hackerrank.com/challenges/candies"&gt;puzzle&lt;/a&gt; is in the DP section of HackerRank. With DP, you expect a recursive solution is expected, which is less memory efficient. Therefore, you should find a way to memoize/cache results of previous calculations to make it pass. &lt;/p&gt;
&lt;h2&gt;Problem statement:&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Given an array of students&amp;#39; grades (ints) in the same order as they sit. Return the minimal number of candies all students receive, such that:
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;out of 2 adjacent students, the one with a higher grade receives more candy&lt;/li&gt;
&lt;li&gt;each student receives at least 1 piece of candy&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Plot twist&lt;/h3&gt;
&lt;p&gt;Alternatively, you can look at the problem as a graph theory problem. &lt;/p&gt;
&lt;p&gt;Represent each student as a node on a plane. Among adjacent nodes, draw directed edges from the node with a lower grade to the node with a higher grade. All the nodes without incoming edges aren't greater than their neighbours (equal grades means you can give less candy), so they will receive the minimum amount - 1. Now start several breadth-first searches from each of the nodes without incoming edges (they will be the local start points). Visit node and increment the value at its index in the candies array. Differently to normal breadth-first search, you don't need to keep track of previously visited nodes and you can revisit them to increment the counter. In case you have a peak around a point 8 (index = 3) eg&lt;/p&gt;
&lt;p&gt;grades
1 2 4 8 6 5 3 2 1&lt;/p&gt;
&lt;p&gt;candies (illegal) - if you don't revisit nodes to update counter. 
1 2 3 4 5 4 3 2 1 &lt;/p&gt;
&lt;p&gt;candies (solution)
1 2 3 6 5 4 3 2 1&lt;/p&gt;
&lt;h3&gt;Complexity&lt;/h3&gt;
&lt;p&gt;The prepare_for_bfs method takes linear O(n) time and bfs takes maximum O(V + E)&lt;/p&gt;
&lt;p&gt;The code is &lt;a href="https://github.com/petr-tik/misc/blob/master/candies.py"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you see a problem in description or the code, please open issues, send PRs&lt;/p&gt;</summary><category term="python"></category><category term="algorithms"></category><category term="hackerrank"></category></entry><entry><title>Getting clojure with Lisp</title><link href="/getting-clojure-with-lisp.html" rel="alternate"></link><updated>2016-02-20T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2016-02-20:getting-clojure-with-lisp.html</id><summary type="html">&lt;p&gt;I have spent the weekend reading and getting my head around Clojure and here are my first thoughts.&lt;/p&gt;
&lt;p&gt;It's definitely a great exercise and even if I will never get to write a single line of code in a functional language in my life, I will be more confident using map, filter and reduce in python. &lt;/p&gt;
&lt;p&gt;Adopting the immutable data approach, makes me really concentrate on the quality and good compositionality of the functions, where I really think through how to make a series of pure functions, whose output will feed into the next one's input well. WHile REPL-based development is helpful to try defn functions on the fly to experiment, my python background is annoyed that I cannot just print the state of the programme at every step: 
i) pure functions are stateless
ii) pure functions have no side effect like printing to the stdout&lt;/p&gt;
&lt;p&gt;As this is an exercise in thinking and writing pure functions, printing to stdout is betraying the clojure way and would involve a helper function that needs to wrap each function and print the arguments and output. &lt;/p&gt;
&lt;p&gt;Going forward, I've been told 4Clojure is a good source of problems and the TDD framework is very thorough. Another upside of pure functions I hope to experience soon is the ease of unit testing them. If you write all helper functions and main the UNIX way, you should be able to test each of them separately and when composed with easy input. &lt;/p&gt;
&lt;p&gt;A good exercise, which lends itself nicely to Clojure is checking if a given word and any word from a vector of words have are anagrams. &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagram?&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes 2 words - returns True if they are anagrams, false otherwise&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;word1&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;true&lt;/span&gt;
        &lt;span class="nv"&gt;false&lt;/span&gt;
        &lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagrams&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes a target word and a vector of words &lt;/span&gt;
&lt;span class="s"&gt;Returns a list of anagrams of the target from the vector&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;anagram?&lt;/span&gt; &lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="clojure"></category></entry></feed>