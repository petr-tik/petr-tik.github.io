<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>My blog</title><link href="/" rel="alternate"></link><link href="/feeds/hacking.atom.xml" rel="self"></link><id>/</id><updated>2017-08-05T22:20:00+01:00</updated><entry><title>Diving into CPython GC module</title><link href="/diving-into-cpython-gc-module.html" rel="alternate"></link><updated>2017-08-05T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-08-05:diving-into-cpython-gc-module.html</id><summary type="html">&lt;p&gt;This is a deep dive into the source code for &lt;code&gt;Modules/gcmodule.c&lt;/code&gt; inspired by a previous blogpost, which outlined the GC mechanism in CPython.&lt;/p&gt;
&lt;p&gt;Python uses a generation-based ref-counting GC. The number of generations is defined in a macro as 3, where 0th generation keeps track of most recently allocated objects, 2nd generation of long lived objects. Every gc_generation has a threshold (number of objects after which a collection is performed). &lt;/p&gt;
&lt;p&gt;The thresholds are initiated at 700, 10 and 10 respectively. This means GC will be kicked off for 0th generation, when we allocate 700 new objects or promote 10 objects to either 1st or 2nd generation. First generation can only have 10 objects (objects that survive collection move to a higher generation). The second generation is the oldest, so objects that survive collection move nowhere and stay in the second generation. The difference between 700 and 10 relies on the heuristic that few objects will survive after 1 generation. This optimises the effect of GC on runtime performance working with newly allocated objects. To improve the performance wrt to long-living objects another heuristic is used to avoid collecting the oldest generation, which can have an unlimited number of objects.&lt;/p&gt;
&lt;h2&gt;collect method&lt;/h2&gt;
&lt;p&gt;Below is the main collect method found in &lt;code&gt;Modules/gcmodule.c&lt;/code&gt; annotated with my guesses about the use of each variable.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;understand&lt;/span&gt; &lt;span class="n"&gt;how&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt;
 &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;works&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt;
&lt;span class="n"&gt;collect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;generation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n_collected&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n_uncollectable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nofail&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The method signature. Returns a static signed size_t int. Input is generation (between 0 and 2 - higher is older), pointer to a variable tracking the &lt;code&gt;n\_collected&lt;/code&gt; objects so far, &lt;code&gt;uncollectable&lt;/code&gt; and &lt;code&gt;nofail&lt;/code&gt; variable. Looking ahead &lt;code&gt;nofail&lt;/code&gt; is only used once to decide if an error message should be printed to terminal. Both Py_ssize_t objects - &lt;code&gt;n\_collected&lt;/code&gt; and &lt;code&gt;n\_uncollectable&lt;/code&gt; - will be updated in-place (at their addresses) with m and n respectively.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="c"&gt;# objects collected */&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="c"&gt;# unreachable objects that couldn&amp;#39;t be collected */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Original code has m and n. Not a fan of this naming convention - I guess programmers in the 90s were paid inversely proportionally to the number of chars they typed. That would explain &lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;creat&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;young&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;generation&lt;/span&gt; &lt;span class="n"&gt;we&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;examining&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt; &lt;span class="n"&gt;older&lt;/span&gt; &lt;span class="n"&gt;generation&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;problematic&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt; &lt;span class="n"&gt;trash&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;reachable&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__del__&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;PyGC_Head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;_PyTime_t&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;initialize&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;prevent&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;compiler&lt;/span&gt; &lt;span class="n"&gt;warning&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Stack allocating the vars we will need to collect this generation with. No other choice - heap allocating variables used in GC is just rude. &lt;/p&gt;
&lt;h3&gt;PyGC_Head&lt;/h3&gt;
&lt;p&gt;Most variables are of type PyGC_Head, whose definition is in &lt;a href="https://github.com/python/cpython/blob/master/Include/objimpl.h#L251-L259"&gt;objimpl.h&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;GC&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;stored&lt;/span&gt; &lt;span class="n"&gt;BEFORE&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="c"&gt;#ifndef Py_LIMITED_API&lt;/span&gt;
&lt;span class="n"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_gc_head&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gc_prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;gc_refs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;force&lt;/span&gt; &lt;span class="n"&gt;worst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;alignment&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyGC_Head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The meaty part of the type is pointers of the same type to next and previous &lt;code&gt;_gc_head&lt;/code&gt; types and the &lt;code&gt;gc_refs&lt;/code&gt; that keeps track of the number of references.&lt;/p&gt;
&lt;p&gt;Paraphrasing the commit message - the &lt;code&gt;double dummy&lt;/code&gt; is to make sure 8-byte alignment won't break. When 8-byte alignment is required, padding is added, otherwise, there won't be any change.&lt;/p&gt;
&lt;h2&gt;Back to collect&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    struct gc_generation_stats *stats = &amp;amp;generation_stats[generation];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Added 5 years ago as part of &lt;code&gt;gc.get_stats&lt;/code&gt; modules. Pointer to stack-allocated generation_stats struct, which keeps track of the number of collections performed, objects collected and marked as uncollectable.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;DEBUG_STATS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;PySys_WriteStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;gc: collecting generation %d...\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;generation&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;PySys_WriteStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;gc: objects in each generation:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;NUM_GENERATIONS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;PySys_FormatStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; %zd&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                              &lt;span class="n"&gt;gc_list_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GEN_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
        &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_PyTime_GetMonotonicClock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;PySys_WriteStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;PyDTrace_GC_START_ENABLED&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
        &lt;span class="nt"&gt;PyDTrace_GC_START&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;generation&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debugging and tracing boilerplate. Useful but not for the purpose of this blog.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* update collection and allocation counters */
    if (generation+1 &amp;lt; NUM_GENERATIONS)
        generations[generation+1].count += 1;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Given the default NUM_GENERATIONS, this will only work on 2 youngest generations (0, 1) and increment the count of allocations or collections of the older generation from the current.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    for (i = 0; i &amp;lt;= generation; i++)
        generations[i].count = 0;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reset the count of allocations and collections of generations up to current to 0. Every time we collect generations up to value X, we reset their counts.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* merge younger generations with one we are currently collecting */
    for (i = 0; i &amp;lt; generation; i++) {
        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Prepare for collection by merging all generations into the generation that is currently being collected. Uses gc_list_merge, which appends the younger generation to the list of the currently collected generation.&lt;/p&gt;
&lt;h3&gt;gc_list_merge&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* append list `from` onto list `to`; `from` becomes an empty list */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
static&lt;span class="w"&gt; &lt;/span&gt;void&lt;span class="w"&gt;&lt;/span&gt;
gc_list_merge&lt;span class="o"&gt;(&lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;from&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;PyGC_Head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;tail&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;assert&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;gc_list_is_empty&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;tail&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tail&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_prev&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;gc&lt;span class="o"&gt;.&lt;/span&gt;gc_next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;to&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;gc_list_init&lt;span class="o"&gt;(&lt;/span&gt;from&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This uses a sentinel doubly linked list. An empty linked list contains one node, whose &lt;code&gt;.gc_prev&lt;/code&gt; and &lt;code&gt;.gc_next&lt;/code&gt; link to the node itself. By creating a variable for &lt;code&gt;tail&lt;/code&gt;, we can save the pointer to the last node in the to list. First, we link the second node in the from list with the end of the to list using the &lt;code&gt;tail&lt;/code&gt; variable. The second node in the from list becomes the head of the merged list. At the end, we make the head node of the to list point its prev pointer to the last node of the from list and the next pointer of the last node of the from list to the first node of the to list. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;gc_list_init&lt;/code&gt; makes the sentinel node points both pointers to itself. The first node in any gc list is therefore always a sentinel node. &lt;/p&gt;
&lt;p&gt;Therefore we merge the &lt;code&gt;from&lt;/code&gt; list to the left of the &lt;code&gt;to&lt;/code&gt; list. In a full collection, the 0th generation is merged with the 2nd first. The result, where the nodes from the 0th collection are to the left of the nodes from the 2nd collection, is merged with the 1st generation. This results in the following order:&lt;/p&gt;
&lt;p&gt;1st generation -&amp;gt; 0th generation -&amp;gt; 2nd generation&lt;/p&gt;
&lt;h2&gt;Back to collect&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* handy references */
    young = GEN_HEAD(generation);
    if (generation &amp;lt; NUM_GENERATIONS-1)
        old = GEN_HEAD(generation+1);
    else
        old = young;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Having defined young earlier (currently collected generation) and old (generation right of current) now give them values. &lt;code&gt;young&lt;/code&gt; acquires the value of the gc_list, which now contains the result of merging all previous generations with the current. &lt;code&gt;old&lt;/code&gt; is set to the head of generation to the right, if it exists. eg. when generation = 2, old = young. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* Using ob_refcnt and gc_refs, calculate which objects in the
     * container set are reachable from outside the set (i.e., have a
     * refcount greater than 0 when all the references within the
     * set are taken into account).
     */
    update_refs(young);
    subtract_refs(young);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;update_refs&lt;/code&gt; and then &lt;code&gt;substract_refs&lt;/code&gt; prepares the young generation of collection. At the start of a collection, &lt;code&gt;update_refs()&lt;/code&gt; copies the true refcount to gc_refs, for each object in the generation being collected. &lt;code&gt;subtract_refs()&lt;/code&gt; then adjusts gc_refs so that it equals the number of times an object is referenced directly from outside the generation being collected.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* Leave everything reachable from outside young in young, and move
     * everything else (in young) to unreachable.
     * NOTE:  This used to move the reachable objects into a reachable
     * set instead.  But most things usually turn out to be reachable,
     * so it&amp;#39;s more efficient to move the unreachable things.
     */
    gc_list_init(&amp;amp;unreachable);
    move_unreachable(young, &amp;amp;unreachable);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Initialise list of unreachable object with a stack-allocated unreachable variable. &lt;code&gt;move_unreachable&lt;/code&gt; walks across the list of young, where objects have had their ob_refcnt and gc_refs updated. Those with refcount &amp;lt;= 0 are moved into unreachable list. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* Move reachable objects to next generation. */
    if (young != old) {
        if (generation == NUM_GENERATIONS - 2) {
            long_lived_pending += gc_list_size(young);
        }
        gc_list_merge(young, old);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we aren't collecting the oldest generation, this isn't a full collection. If we are collecting the 0th generation, add the number of objects to &lt;code&gt;long_lived_pending&lt;/code&gt; var and merge the lists. Keeping track of the number of objects that survived the collection in &lt;code&gt;young&lt;/code&gt;, but are yet to go through a full collection is used in &lt;code&gt;collect_generations&lt;/code&gt;. &lt;/p&gt;
&lt;h3&gt;long-lived objects&lt;/h3&gt;
&lt;p&gt;Long-lived objects are those in generation 2. The first 2 generations are bounded by thresholds, whereas generation 2 can grow without a limit. Collecting all generations (called full collection) including the 2nd every time, would lead to quadratic running time. A heuristic is used to reduce it. We can either skip objects or perform fewer collections. A limit of 25% between objects that are yet to go through a full collection over the number of objects that survived the last collection in generation 2. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;static Py_ssize_t
collect_generations(void)
{
    ...
    for (i = NUM_GENERATIONS-1; i &amp;gt;= 0; i--) {
        if (generations[i].count &amp;gt; generations[i].threshold) {
    ...
        if (i == NUM_GENERATIONS - 1
                &amp;amp;&amp;amp; long_lived_pending &amp;lt; long_lived_total / 4)
                continue;
            n = collect_with_callback(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We invoke a full collection if more than 25% of the objects have been allocated since the last full collection.&lt;/p&gt;
&lt;h2&gt;back to collect&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    else {
        /* We only untrack dicts in full collections, to avoid quadratic
           dict build-up. See issue #14775. */
        untrack_dicts(young);
        long_lived_pending = 0;
        long_lived_total = gc_list_size(young);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Perform a full collection. We don't move anything anywhere, just reset &lt;code&gt;long_lived_pending&lt;/code&gt; (no object has not survived a full collection) and update &lt;code&gt;long_lived_total&lt;/code&gt; with the number of objects left. &lt;/p&gt;
&lt;h3&gt;untracking immutable objects like dicts&lt;/h3&gt;
&lt;p&gt;Python has a mix of immutable and mutable data structures. Tuples and strings are strictly immutable in python. Every modification of an existing tuple/string, allocates a new object of the same type, applies the transformation in-memory and copies the result into the newly allocated object. Appending a new char to a string, allocates a new string object and sets its values to old_string + new_char. Tuples are different from strings, because they are container objects i.e. they keep track of other objects inside. An immutable container like tuple may contain a mutable object like a list, which needs GC. A completely immutable object - tuple of tuples/integers/strings will neither change as a container nor as its members. Therefore there is no need to GC track it. By default, we still track newly created tuples and leave it to the GC to untrack it.&lt;/p&gt;
&lt;p&gt;Dictionaries containing only immutable objects like strings also don’t need tracking. Dictionaries are untracked by default, but become tracked as soon as a mutable object is added (using an int as a key). Protip: use strings as keys and tuples as values to avoid invoking GC on your dictionaries.&lt;/p&gt;
&lt;h2&gt;Back to collect&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;trash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;reachable&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;legacy&lt;/span&gt; &lt;span class="n"&gt;finalizers&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;tp_del&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;t safely be deleted.&lt;/span&gt;
     &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;gc_list_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;move_legacy_finalizers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;finalizers&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;legacy&lt;/span&gt; &lt;span class="n"&gt;finalizer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;reachable&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;those&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;uncollectable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;we&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;those&lt;/span&gt; &lt;span class="n"&gt;into&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;finalizers&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;too&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
     &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;move_legacy_finalizer_reachable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If unreachable objects have finalizers, we need to check if they may be reachable. If so, we can recover them.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Collect&lt;/span&gt; &lt;span class="n"&gt;statistics&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;collectable&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;debugging&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
     &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;DEBUG_COLLECTABLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;debug_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;collectable&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FROM_GC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Clear&lt;/span&gt; &lt;span class="n"&gt;weakrefs&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="n"&gt;callbacks&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;necessary&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;handle_weakrefs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Adds debugging and stats. Tidies up all objects in &lt;code&gt;unreachable&lt;/code&gt; and guarantees that none of them have weakrefs to other objects.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* Call tp_finalize on objects which have one. */
    finalize_garbage(&amp;amp;unreachable);


    if (check_garbage(&amp;amp;unreachable)) {
        revive_garbage(&amp;amp;unreachable);
        gc_list_merge(&amp;amp;unreachable, old);
    }
    else {
        /* Call tp_clear on objects in the unreachable set.  This will cause
         * the reference cycles to be broken.  It may also cause some objects
         * in finalizers to be freed.
         */
        delete_garbage(&amp;amp;unreachable, old);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;finalise_garbage&lt;/code&gt; calls objects' custom destructors. &lt;code&gt;check_garbage&lt;/code&gt; uses &lt;code&gt;substract_refs&lt;/code&gt; to check if the objects in &lt;code&gt;unreachable&lt;/code&gt; have references to each other or objects outside. If they turn out to have refs to objects outside of &lt;code&gt;unreachable&lt;/code&gt;, &lt;code&gt;revive_garbage&lt;/code&gt; sets all objects' &lt;code&gt;gc_refs&lt;/code&gt; to GC_REACHABLE and merges the whole list with &lt;code&gt;old&lt;/code&gt; generation. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;delete_garbage&lt;/code&gt; traverses through the &lt;code&gt;unreachable&lt;/code&gt; list and if it has a &lt;code&gt;tp_clear&lt;/code&gt; method, invokes it. If the object is still alive after that, its &lt;code&gt;gc_refs&lt;/code&gt; is set to GC_REACHABLE and it's moved to the &lt;code&gt;old&lt;/code&gt; generation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Collect&lt;/span&gt; &lt;span class="n"&gt;statistics&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;uncollectable&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;debugging&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="n"&gt;gc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc_next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;DEBUG_UNCOLLECTABLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;debug_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;uncollectable&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FROM_GC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;DEBUG_STATS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;_PyTime_t&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_PyTime_GetMonotonicClock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;PySys_WriteStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;gc: done&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;PySys_FormatStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="s"&gt;&amp;quot;gc: done, %zd unreachable, %zd uncollectable&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;PySys_WriteStderr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;, &lt;/span&gt;&lt;span class="si"&gt;%.4f&lt;/span&gt;&lt;span class="s"&gt;s elapsed&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;_PyTime_AsSecondsDouble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Deals with stats and debugging collection.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Append&lt;/span&gt; &lt;span class="n"&gt;instances&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;uncollectable&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;reachable&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;garbage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;programmer&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;deal&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;they&lt;/span&gt; &lt;span class="n"&gt;insist&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;creating&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
     &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;handle_legacy_finalizers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;finalizers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;finalizers is unreachable objects with legacy finalizers, so need to be dealt with differently. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Clear&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="n"&gt;during&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;highest&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;generation&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generation&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;NUM_GENERATIONS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;clear_freelists&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Clearing freelists&lt;/h3&gt;
&lt;p&gt;Full collection (collecting the oldest generation) involves clearing freelists. Recall that free lists are lists of primitive Python object types. When the CPython interpreter starts, it allocates lists of free dicts/lists/sets of predetermined size, so first X object creations don’t involve malloc calls. Similarly, when an object is deallocated, it's just returned to the free_list of that PyObject type instead of calling free. Only if your programme uses more objects than originally allocated, will you call malloc. Eg from &lt;code&gt;dictobject.c&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Size of freelist for dictionary&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#ifndef PyDict_MAXFREELIST&lt;/span&gt;
&lt;span class="c"&gt;#define PyDict_MAXFREELIST 80&lt;/span&gt;
&lt;span class="c"&gt;#endif&lt;/span&gt;
&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PyDict_MAXFREELIST&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The CPython interpreter allocates a list of 80 dictionary objects. The commit adding free_lists and their sizes is an old svn commit with more than a dozen of features in one commit, without explanation or inability to recover the reasoning behind 80.&lt;/p&gt;
&lt;h4&gt;Using a freelist to alloc/free dictionaries&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt;
&lt;span class="n"&gt;new_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDictKeysObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using numfree as index into the array of preallocated data types (eg. dictionaries), we assign mp to a dictionary from the list. If all dictionaries in the freelist have been used already, we have to allocate our own. Interestingly enough, &lt;code&gt;if (numfree)&lt;/code&gt; will also execute the branch, if numfree is negative, which is semantically incorrect. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt;
&lt;span class="n"&gt;dict_dealloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;PyDict_MAXFREELIST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Py_TYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;PyDict_Type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we haven't allocated all dictionaries from the freelist, it means, we can return the current dictionary to the list. Otherwise, it must have been allocated by our programme, not the intepreter at start-up, hence we need to explicitly free it.&lt;/p&gt;
&lt;h3&gt;Clearing dictionaries&lt;/h3&gt;
&lt;p&gt;Each of the listed types in their &lt;code&gt;Objects/dictobject.c&lt;/code&gt; source files have a method for clearing the list of free dictionaries to use. Curiously, the PyDict_ClearList method returns the number of freed objects, but all invocations of the method cast the return type to void, making you wonder, why it returns anything in the first place. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;PyDict_ClearFreeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numfree&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDict_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;PyObject_GC_Del&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;PyObject_FREE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys_free_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numfreekeys&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;back to collect&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyErr_Occurred&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nofail&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;PyErr_Clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc_str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;gc_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyUnicode_FromString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;garbage collection&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;PyErr_WriteUnraisable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc_str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;Py_FatalError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unexpected exception during garbage collection&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Error handling code. This catches the error and writes to terminal a generic crash message.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Update&lt;/span&gt; &lt;span class="n"&gt;stats&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_collected&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n_collected&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_uncollectable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n_uncollectable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;collected&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uncollectable&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDTrace_GC_DONE_ENABLED&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;PyDTrace_GC_DONE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Updates the stats for number of objects collected and unreachable objects and increments the counter for number of collections performed. The method returns the number of objects collected and unreachable in this generation.&lt;/p&gt;
&lt;h3&gt;Collecting&lt;/h3&gt;
&lt;p&gt;Gc_refs values determine if an object should be collected. When an object is malloc’ed, its gc_refs is set to GC_UNTRACKED, because it’s absent from any generation list. &lt;/p&gt;
&lt;p&gt;As soon as it’s added to a generation list its gc_refs is updated to GC_REACHABLE.&lt;/p&gt;
&lt;p&gt;When collecting happens, gc_refs may take other values. The most important is GC_TENTATIVELY_UNREACHABLE, which means the object has been moved to the unreachable set. Even when ref updating is over and an object is GC_TENTATIVELY_UNREACHABLE, it may be made reachable again, because it has a &lt;code&gt;__del__&lt;/code&gt; method. This is done with a revive_garbage method, which takes a pointer to list of supposedly unreachable objects, which turned out to have refs to objects outside their own group.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This blog is a read-through of the &lt;code&gt;Modules/gcmodule.c&lt;/code&gt; of the CPython interpreter. The logic is inside the &lt;code&gt;collect&lt;/code&gt; method, which is called by &lt;code&gt;collect_with_callback&lt;/code&gt;. The &lt;code&gt;gc&lt;/code&gt; module exposes the &lt;code&gt;gc.collect()&lt;/code&gt; method that users can manually activate in terminal, which performs a full collection. Some heuristics and tips to use CPython efficiently were explained and internals of object allocation/collection were outlined. &lt;/p&gt;</summary><category term="python"></category><category term="gc"></category><category term="memory"></category></entry><entry><title>Comparing different ways to add ints II</title><link href="/comparing-different-ways-to-add-ints-ii.html" rel="alternate"></link><updated>2017-07-16T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-07-16:comparing-different-ways-to-add-ints-ii.html</id><summary type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;As outlined in &lt;a href="/comparing-different-ways-to-add-ints-i.html"&gt;part 1&lt;/a&gt;, we are comparing recursive and iterative implementations of long arithmetic of 2 arrays. As seen in the chart at the bottom of the post, there is a sudden jump in execution times of the recursive function, when the length of array becomes ~900 ints. Using the &lt;code&gt;cProfile&lt;/code&gt; and &lt;code&gt;line_profile&lt;/code&gt; modules in Python, this increase in execution times is investigated in this post. First cProfile was used to record and examine the execution times for &lt;code&gt;recur_sum&lt;/code&gt; and &lt;code&gt;iter_sum&lt;/code&gt;. After the bottlenecks were located, &lt;code&gt;line_profiler&lt;/code&gt; was used to profile each function with higher granularity. To guarantee consistent analysis both implementations will be benchmarked with line profiling enabled. &lt;/p&gt;
&lt;h2&gt;Refactoring&lt;/h2&gt;
&lt;p&gt;The script from part 1 had to be changed to profile the relevant function calls and save the results. This effectively wraps the function calls with cProfiler and then saves the results into a .dmp type. Afterwards results are plotted.&lt;/p&gt;
&lt;h3&gt;Plot results&lt;/h3&gt;
&lt;p&gt;Instead of using a scatter plot, normal plot was used, which made the increase in gradient more obvious. It also takes the right and left limits to the x values (lengths of the array). Setting xlim to the plot will help us focus the picture. We will not exceed recursion depth in this example. Hence we won't be marking the last point in recursive times.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;plot_results_for_cprofile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Size of input arrays&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Time to calculate sum (ms)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Comparing iterative vs recursive sum methods&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
    &lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recurs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;

    &lt;span class="c"&gt;# plot iterative times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# plot recursive times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;green&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;plot_sum_ints.png&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;savefig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dpi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Saved plot as {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Profile run&lt;/h3&gt;
&lt;p&gt;Profile run method instantiates 2 &lt;code&gt;cProfile.Profile()&lt;/code&gt; classes for iterative and recursive solution profiling. Looping over different array lengths, the &lt;code&gt;iter_sum&lt;/code&gt; and &lt;code&gt;recur_sum&lt;/code&gt; solutions are profiled. The profiling information is saved to disk using the &lt;code&gt;dump_stats()&lt;/code&gt; method, which takes a string for argument name. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;profile_run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cProfile&lt;/span&gt;
    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;iter_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

        &lt;span class="n"&gt;pr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cProfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Profile&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cProfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Profile&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;iter_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_recur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recur_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;pr2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recur_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_recur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;plot_results_for_cprofile&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Dumping stats&lt;/h3&gt;
&lt;p&gt;Used the length of input arrays as id of this profiler run. Looking at the &lt;a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/cProfile.py#L44-L48"&gt;source&lt;/a&gt; for cProfile.Profile.dump_stats()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;marshal&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_stats&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;marshal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We see that it uses the marshal module. From the &lt;a href="https://docs.python.org/3/library/marshal.html"&gt;documentation&lt;/a&gt;, we know that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Details of the format are undocumented on purpose; it may change between Python versions (although it rarely does).&lt;/p&gt;
&lt;p&gt;This is not a general "persistence" module. For general persistence and transfer of Python objects through RPC calls, see the modules :mod:&lt;code&gt;pickle&lt;/code&gt; and :mod:&lt;code&gt;shelve&lt;/code&gt;. The :mod:&lt;code&gt;marshal&lt;/code&gt; module exists mainly to support reading and writing the "pseudo-compiled" code for Python modules of :file:&lt;code&gt;.pyc&lt;/code&gt; files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you're serializing and de-serializing Python objects, use the :mod:&lt;code&gt;pickle&lt;/code&gt; module instead -- the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal.&lt;/p&gt;
&lt;p&gt;The :mod:&lt;code&gt;marshal&lt;/code&gt; module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What joy! &lt;code&gt;cProfile&lt;/code&gt; (the builtin python profiler) uses a badly documented, backwards-incompatible, insecure module with incomplete support for Python types.&lt;/p&gt;
&lt;h3&gt;Line profiling&lt;/h3&gt;
&lt;p&gt;Line profiling was implemented by changing the code for the &lt;code&gt;timeit&lt;/code&gt; decorator function. This allowed repeat measurements to stay consistent between recursive and iterative methods. Assuming that the overhead of line profiling of the recursive and iterative solution is in the same order of magnitude, wrapping both &lt;code&gt;recur_sum&lt;/code&gt; and &lt;code&gt;iter_sum&lt;/code&gt; wasn't expected to change the difference between them too much. &lt;code&gt;recur_sum_helper&lt;/code&gt; and &lt;code&gt;iter_sum_helper&lt;/code&gt; had to be moved above &lt;code&gt;timeit&lt;/code&gt; in the source code (reasons below). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;str_func_to_profile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__code__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;co_names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;func_to_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="n"&gt;str_func_to_profile&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;newfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# locals() returns a dictionary, where &amp;#39;args&amp;#39; is key for local vars&lt;/span&gt;
        &lt;span class="c"&gt;# ASSUMPTION: both input arrays have the same length, use either&lt;/span&gt;
        &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;locals&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;args&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="c"&gt;# make a new instance of LineProfiler for each time iter_sum() is&lt;/span&gt;
        &lt;span class="c"&gt;# called with new input arrays&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineProfiler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;func_prof&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func_to_prof&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;startTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func_prof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;startTime&lt;/span&gt;
        &lt;span class="n"&gt;line_prof&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ll_{}_{}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;str_func_to_profile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;time_as_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{:.6f}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_as_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newfunc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Below is a quick introduction to python decorators and how the timeit function had to change to include line profiling.&lt;/p&gt;
&lt;h4&gt;Decorators are evaluated at runtime&lt;/h4&gt;
&lt;p&gt;When a python module is loaded or runs, the wrappers are evaluated, as soon as they are encountered. Regardless if the wrapped function is even called anywhere in the module, the decorator processes and returns the new function, as soon as it is given a function to wrape. When the wrapped function is called, it has already been modified, so the function being executed is function that the decorator returned, when it was evaluated earler. To prove that decorators work at wrap-time, not call-time, set breakpoits &lt;code&gt;pdb.set_trace()&lt;/code&gt; as below. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pdb&lt;/span&gt;
&lt;span class="n"&gt;pdb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_trace&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# breakpoint 1&lt;/span&gt;

&lt;span class="nd"&gt;@timeit&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iter_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r_arr2&lt;/span&gt;&lt;span class="p"&gt;)[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;pdb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_trace&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# breakpoint 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When breakpoint 1 is hit, &lt;code&gt;iter_sum&lt;/code&gt; hasn't been defined, so the Python interpreter throws a NameError. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; python3 sum_ints_as_arrays.py 
&amp;gt; /home/petr_tik/Coding/misc/misc/sum_ints_profile/sum_ints_as_arrays.py&lt;span class="o"&gt;(&lt;/span&gt;115&lt;span class="o"&gt;)&lt;/span&gt;&amp;lt;module&amp;gt;&lt;span class="o"&gt;()&lt;/span&gt;
-&amp;gt; @timeit
&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__name__
*** NameError: name &lt;span class="s1"&gt;&amp;#39;iter_sum&amp;#39;&lt;/span&gt; is not defined
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;(c)ontinuing&lt;/code&gt; to breakpoint 2, now &lt;code&gt;iter_sum&lt;/code&gt; has been defined and wrapped. &lt;code&gt;newfunc&lt;/code&gt; is the name that  came from the closure of &lt;code&gt;timeit&lt;/code&gt;. This proves that &lt;code&gt;iter_sum&lt;/code&gt; has already been wrapped by timeit, before it's first called.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; c
&amp;gt; /home/petr_tik/Coding/misc/misc/sum_ints_profile/sum_ints_as_arrays.py&lt;span class="o"&gt;(&lt;/span&gt;124&lt;span class="o"&gt;)&lt;/span&gt;&amp;lt;module&amp;gt;&lt;span class="o"&gt;()&lt;/span&gt;
-&amp;gt; @timeit
&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__name__
&lt;span class="s1"&gt;&amp;#39;newfunc&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Closures&lt;/h4&gt;
&lt;p&gt;Decorators in Python rely on the concept of closure. At the time when newfunc is defined inside the &lt;code&gt;timeit&lt;/code&gt; function, there are 3 variables available to newfunc: str_func_to_profile, func_to_prof and func (wrapped function) itself. Continuing the same pdb session, freevars inside the code object of &lt;code&gt;iter_sum&lt;/code&gt; were examined.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;Pdb&lt;span class="o"&gt;)&lt;/span&gt; iter_sum.__code__.co_freevars
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;func&amp;#39;&lt;/span&gt;, &lt;span class="s1"&gt;&amp;#39;func_to_prof&amp;#39;&lt;/span&gt;, &lt;span class="s1"&gt;&amp;#39;str_func_to_profile&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Adding line-profiling to the decorator&lt;/h4&gt;
&lt;p&gt;Using the above and some &lt;a href="https://docs.python.org/3/library/inspect.html"&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; hackery, we access the code object of func using  &lt;code&gt;__code__&lt;/code&gt;. &lt;code&gt;co_names&lt;/code&gt; returns a tuple of names of local variables. Both input funcs - &lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt; only have 1 local variable - its helper function. &lt;code&gt;iter_sum_helper&lt;/code&gt; and &lt;code&gt;recur_sum_helper&lt;/code&gt; are above this wrapper function in the source code. This guarantees that they will be found when &lt;code&gt;globals&lt;/code&gt; is called inside the decorator. Using the string as the key, we retrieve the function object from the globals() dictionary. &lt;/p&gt;
&lt;p&gt;Originally, I made a mistake by instantiating the &lt;code&gt;LineProfiler&lt;/code&gt; class inside &lt;code&gt;timeit&lt;/code&gt;, but before &lt;code&gt;newfunc&lt;/code&gt; is defined. This made the same instance of the &lt;code&gt;LineProfiler&lt;/code&gt; object availabe to all calls of &lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt; respectively. This would append profiling results into the same file, which was later dumped under a new name. Profiling data for &lt;code&gt;recur_sum_919&lt;/code&gt; included the profiling data for all previous runs, which made it incorrect. Instead, each time a function is called, a new instance of the &lt;code&gt;LineProfiler&lt;/code&gt; is created, when the input func (&lt;code&gt;iter_sum&lt;/code&gt; or &lt;code&gt;recur_sum&lt;/code&gt;) is called. &lt;/p&gt;
&lt;p&gt;Overall running times are still collected and returned and they are expected to increase with the overhead of line profiling. The line profiler dumps stats into a file called by its function name and array length. The result and elapsed time are returned, used by &lt;code&gt;profile_run&lt;/code&gt; to collect and plot time for each function call.&lt;/p&gt;
&lt;h2&gt;Results&lt;/h2&gt;
&lt;h3&gt;Plot&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_profiler.png" /&gt;&lt;/p&gt;
&lt;p&gt;In the graph, green is still recursive, red is iterative times. There are several notables differences - times are higher overall - profiling has a noticeable overhead. The difference between iterative and recursive is still present and the shape of ups/downs is similar in both lines . There is a huge spike for the recursive solution when the input arrays are of size 907. This makes it easy to investigate function calls.&lt;/p&gt;
&lt;h3&gt;Reading the cProfile dump&lt;/h3&gt;
&lt;h4&gt;Read function&lt;/h4&gt;
&lt;p&gt;All instances of cProfile for each array length &lt;code&gt;dump_stats&lt;/code&gt; into plaintext files recur_{arr_length} or iter_{arr_length}. &lt;code&gt;read_dump.py&lt;/code&gt; is defined to print the dump to terminal to investigate, grep and read through it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pstats&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Supply a filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;stats&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pstats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Results&lt;/h4&gt;
&lt;p&gt;Using this script, we examine the dumps of recursive calls with arrays of lengths 917 and 918 (before, during and after the peak).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_917 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5542&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4625&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_918 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5548&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4630&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.039 seconds
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_dump.py recur_919 &lt;span class="p"&gt;|&lt;/span&gt; grep seconds
         &lt;span class="m"&gt;5554&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4635&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At the peak, the number of function calls increases by 5, but the execution time more than triples.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;petr_tik@merluza:~/Coding/misc/misc/sum_ints_profile&lt;span class="nv"&gt;$ &lt;/span&gt;./read_dump.py recur_917 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./read_dump.py recur_918 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./read_dump.py recur_919
Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_917
         &lt;span class="m"&gt;5542&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4625&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    918/1    0.010    0.000    0.011    0.011 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;

Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_918
         &lt;span class="m"&gt;5548&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4630&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.039 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    919/1    0.038    0.000    0.038    0.038 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;

Sun Jul &lt;span class="m"&gt;23&lt;/span&gt; 19:18:39 &lt;span class="m"&gt;2017&lt;/span&gt;    recur_919
         &lt;span class="m"&gt;5554&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; calls &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4635&lt;/span&gt; primitive calls&lt;span class="o"&gt;)&lt;/span&gt; in 0.011 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    920/1    0.010    0.000    0.011    0.011 sum_ints_as_arrays.py:52&lt;span class="o"&gt;(&lt;/span&gt;recur_sum_helper&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In all three (and we can assume other) instances of &lt;code&gt;recur_sum&lt;/code&gt;, nearly 100% of time is spent on recursive calls of &lt;code&gt;recur_sum_helper&lt;/code&gt;. We will need to use line_profiling to get more detail about the increase in execution times. &lt;/p&gt;
&lt;h3&gt;Reading line profiling dump&lt;/h3&gt;
&lt;h4&gt;Read function&lt;/h4&gt;
&lt;p&gt;The line_profiler module has separate function for loading stats and showing text of the stats object. For serialisation, the line profiler module uses the builtin pickle module, which has wider coverage and better support. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#! /usr/bin/env python3&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;line_profiler&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;load_stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;show_text&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Supply a filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;stats&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;load_stats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;show_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Results&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_917
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.006587 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;481&lt;/span&gt;      0.5      7.3      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;2&lt;/span&gt;      2.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;926&lt;/span&gt;      1.0     14.1      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;797&lt;/span&gt;      0.9     12.1      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;782&lt;/span&gt;      0.9     11.9      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;         &lt;span class="m"&gt;1109&lt;/span&gt;      1.2     16.8      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;842&lt;/span&gt;      0.9     12.8      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;          &lt;span class="m"&gt;564&lt;/span&gt;      0.6      8.6      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;917&lt;/span&gt;         &lt;span class="m"&gt;1081&lt;/span&gt;      1.2     16.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.010676 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.1      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;7&lt;/span&gt;      7.0      0.1      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;10658&lt;/span&gt;  10658.0     99.8      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_918
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.034118 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;472&lt;/span&gt;      0.5      1.4      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;3&lt;/span&gt;      3.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;892&lt;/span&gt;      1.0      2.6      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;763&lt;/span&gt;      0.8      2.2      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;776&lt;/span&gt;      0.8      2.3      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;         &lt;span class="m"&gt;1062&lt;/span&gt;      1.2      3.1      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;814&lt;/span&gt;      0.9      2.4      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;          &lt;span class="m"&gt;542&lt;/span&gt;      0.6      1.6      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;918&lt;/span&gt;        &lt;span class="m"&gt;28792&lt;/span&gt;     31.4     84.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.038265 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.0      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;6&lt;/span&gt;      6.0      0.0      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;38248&lt;/span&gt;  38248.0    100.0      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./read_ll.py ll_recur_sum_helper_919
Timer unit: 1e-06 s

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.006544 s
File: sum_ints_as_arrays.py
Function: recur_sum_helper at line 52

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
    &lt;span class="m"&gt;52&lt;/span&gt;                                           def recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, &lt;span class="nv"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0, &lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt;, &lt;span class="nv"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;53&lt;/span&gt;       &lt;span class="m"&gt;920&lt;/span&gt;          &lt;span class="m"&gt;495&lt;/span&gt;      0.5      7.6      &lt;span class="k"&gt;if&lt;/span&gt; not res:
    &lt;span class="m"&gt;54&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;2&lt;/span&gt;      2.0      0.0          &lt;span class="nv"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; list&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="m"&gt;55&lt;/span&gt;       &lt;span class="m"&gt;920&lt;/span&gt;          &lt;span class="m"&gt;936&lt;/span&gt;      1.0     14.3      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt; and idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;56&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 1:
    &lt;span class="m"&gt;57&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;1&lt;/span&gt;      1.0      0.0              res.append&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;58&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;0&lt;/span&gt;      0.0      0.0          &lt;span class="k"&gt;return&lt;/span&gt; res
    &lt;span class="m"&gt;59&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;788&lt;/span&gt;      0.9     12.0      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr1&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;60&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;61&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;62&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;63&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;64&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;785&lt;/span&gt;      0.9     12.0      &lt;span class="k"&gt;if&lt;/span&gt; idx &amp;gt;&lt;span class="o"&gt;=&lt;/span&gt; len&lt;span class="o"&gt;(&lt;/span&gt;arr2&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="m"&gt;65&lt;/span&gt;                                                   carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;66&lt;/span&gt;                                                   res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;67&lt;/span&gt;                                                   idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;68&lt;/span&gt;                                                   &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;69&lt;/span&gt;                                           
    &lt;span class="m"&gt;70&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;         &lt;span class="m"&gt;1107&lt;/span&gt;      1.2     16.9      carry, &lt;span class="nv"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; divmod&lt;span class="o"&gt;(&lt;/span&gt;carry + arr1&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt; + arr2&lt;span class="o"&gt;[&lt;/span&gt;idx&lt;span class="o"&gt;]&lt;/span&gt;, 10&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;71&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;827&lt;/span&gt;      0.9     12.6      res.append&lt;span class="o"&gt;(&lt;/span&gt;item_to_add&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;72&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;          &lt;span class="m"&gt;532&lt;/span&gt;      0.6      8.1      idx +&lt;span class="o"&gt;=&lt;/span&gt; 1
    &lt;span class="m"&gt;73&lt;/span&gt;       &lt;span class="m"&gt;919&lt;/span&gt;         &lt;span class="m"&gt;1071&lt;/span&gt;      1.2     16.4      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2, idx, res, carry&lt;span class="o"&gt;)&lt;/span&gt;

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 0.010754 s
File: sum_ints_as_arrays.py
Function: recur_sum at line 119

Line &lt;span class="c"&gt;#      Hits         Time  Per Hit   % Time  Line Contents&lt;/span&gt;
&lt;span class="o"&gt;==============================================================&lt;/span&gt;
   &lt;span class="m"&gt;119&lt;/span&gt;                                           @timeit
   &lt;span class="m"&gt;120&lt;/span&gt;                                           def recur_sum&lt;span class="o"&gt;(&lt;/span&gt;arr1, arr2&lt;span class="o"&gt;)&lt;/span&gt;:
   &lt;span class="m"&gt;121&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;           &lt;span class="m"&gt;11&lt;/span&gt;     11.0      0.1      &lt;span class="nv"&gt;r_arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr1&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;122&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;            &lt;span class="m"&gt;6&lt;/span&gt;      6.0      0.1      &lt;span class="nv"&gt;r_arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; arr2&lt;span class="o"&gt;[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
   &lt;span class="m"&gt;123&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt;        &lt;span class="m"&gt;10737&lt;/span&gt;  10737.0     99.8      &lt;span class="k"&gt;return&lt;/span&gt; recur_sum_helper&lt;span class="o"&gt;(&lt;/span&gt;r_arr1, r_arr2&lt;span class="o"&gt;)[&lt;/span&gt;::-1&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post showed the use of &lt;code&gt;cProfile&lt;/code&gt; and &lt;code&gt;line_profiler&lt;/code&gt; modules implemented as wrappers to collect and review profiling information. Decorators, which rely on the concept of closures and runtime code inspection, were explained and used for implementing profiling. The spike in execution times of the recursive solution was found using line_profiling. Given arrays of length 918, the recursive sum function for some unexplained reasons takes 28x more time to run than previous and consequent function calls. &lt;/p&gt;
&lt;h2&gt;Future work&lt;/h2&gt;
&lt;p&gt;At this point, it's best to implement tracing either inside python interpreter or from outside the process. By tracing and logging each recursively created and executed stack frame inside &lt;code&gt;recur_sum_helper&lt;/code&gt;, we can get more information about the slowdown. Another avenue for investigation can be looking into CPython source code. Methods like &lt;code&gt;list.append()&lt;/code&gt; might cause reallocation, which would slow down the execution at some stack frames. The line profiling results suggest that would be unlikely, unless they fail to time that.&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>Comparing different ways to add ints I</title><link href="/comparing-different-ways-to-add-ints-i.html" rel="alternate"></link><updated>2017-06-27T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-06-27:comparing-different-ways-to-add-ints-i.html</id><summary type="html">&lt;h2&gt;Puzzle&lt;/h2&gt;
&lt;p&gt;Given 2 ints represented as array of digits in order (eg. 843 = [8, 4, 3]), implement a function that returns a sum of the 2 ints in the same format.&lt;/p&gt;
&lt;p&gt;eg. &lt;/p&gt;
&lt;p&gt;[8, 4, 3] + [1, 8, 2] = [1, 0, 2, 5]&lt;/p&gt;
&lt;h2&gt;Idea&lt;/h2&gt;
&lt;p&gt;Implement and profile recursive and iterative solutions to the puzzle above.&lt;/p&gt;
&lt;h3&gt;Recursive solution&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# guarantee it doesn&amp;#39;t change array outside func scope&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Having done some Clojure, functional tools like map and reduce made it feel that a recursive solution was going to be concise. Handling the same edge cases across different array lengths made the implementation more heavily branched and less pretty than expected.&lt;/p&gt;
&lt;p&gt;The final return statement will activate once idx exhausts both arrays (i.e. incremented beyond both lengths). If the carry bit has been carried over from the previous stack frame, which called this last stack frame, add 1 to the end of the array and return the result. &lt;/p&gt;
&lt;p&gt;Otherwise, if either of the arrays is exhausted, add the ints from the other array keeping carry bit in mind. All 3 cases (arr1 - exhausted, arr2 - not; arr2 - exhaused, arr1 - not; arr1 and arr2 still not exhausted) use divmod function to set the carry bit and item_to_add. On Intel CPUs this should happen in 1 instruction. The only difference is using both arrays if both are still not exhausted.&lt;/p&gt;
&lt;h3&gt;Iterative solution&lt;/h3&gt;
&lt;p&gt;Unrolls the recursive loop. Instead of creating a stack frame for each digit, add as many digits as possible before one of the arrays runs out, then handle the leftover digits from the longer array. In the case of arrays/numbers of the same length, there won't be any branch misprediction and we will fall through down to the return statement.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;divmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item_to_add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Wrapper to time each function call&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;newfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;startTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;startTime&lt;/span&gt;
        &lt;span class="n"&gt;time_as_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{:.6f}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elapsedTime&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_as_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newfunc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This takes the wrapped function, passes the original args, times how long it took to execute and returns a tuple of function return value and time_as_string.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@timeit&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For a fair comparison, both should have the same design and stack allocation strategy. Hence both iter_sum and recur_sum methods reverse the incoming arrays and return the result of the helper. The iterative method calculates everything in 1 stack frame. The recursive recur_sum_helper (by definition) creates a stack frame for each call. &lt;/p&gt;
&lt;p&gt;As both _sum methods prepare and pass reversed arrays into helper methods, the helper methods return the result array in the opposite order. Both _sum methods reverse the return arrays before returning.&lt;/p&gt;
&lt;h4&gt;Bug&lt;/h4&gt;
&lt;p&gt;In the first version of the recur_sum_helper and wrapper there was a bug - the recursive solution returned an array much longer than expected. This was the wrapper's fault, as was proven by running the methods without wrapping and stepping through it with pdb. &lt;/p&gt;
&lt;p&gt;The timeit wrapper method tooks the args and kwargs of the wrappee and kept them across runs. From the second interation onwards, the res array in the wrapped recur_sum_helper was kept inside the wrapper. Python variables are references, so after the res variable was created inside the scope of the wrapper, following &lt;code&gt;res.append&lt;/code&gt; calls grew the same res array as before. &lt;/p&gt;
&lt;p&gt;Adding&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;recur_sum_helper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;solved the problem by creating a new array.&lt;/p&gt;
&lt;h2&gt;Performance comparison&lt;/h2&gt;
&lt;p&gt;Using the script below, the wrapper described above, recursive and iterative solutions were benchmarked. The plots below show show time on the y-axis against the size of 2 input arrays on the x-axis. Green points - recursive times, red - iterative, blue star is the stack length of the array at which stack overflows. Catching stack overflow at runtime has to be done with a try/except loop, which breaks on RuntimeError. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;try_different_lengths_before_breaks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setrecursionlimit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;py_stack_limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;iter_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;recur_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arr_length&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;arr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;arr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="c"&gt;# good test case, because there will be a carry bit over every step&lt;/span&gt;
        &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iter_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time_recur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recur_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;recur_times&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_recur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res_recur&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR - {} != {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res_recur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res_iter&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;RuntimeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c"&gt;# stack limit exceeded&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;iter_times&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_times&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;plot_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1005&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Size of input arrays&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Time to calculate sum (ms)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Comparing iterative vs recursive sum methods&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
    &lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recurs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;
    &lt;span class="n"&gt;point_normal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;point_stack_over&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;

    &lt;span class="c"&gt;# plot iterative times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iters&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_normal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# plot recursive times&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;)[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;)[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_normal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;green&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# last point in recursive times is before stack overflow&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recur_arr_lengths&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recurs&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_stack_over&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;marker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sum_ints_plot.png&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;savefig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dpi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Saved plot as {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Stack depth limits&lt;/h3&gt;
&lt;p&gt;The first discovery was the limit to stack depth (it grows downards, contrary to common sense of adding things to the top of the stack). The default value is 1000 in Python 3.4 (use &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt; to look it up). Considering that recur_sum_helper is called inside recur_sum, which is wrapped and called inside __main__, we only have 996 stack frames for the recursive sum. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$$$&lt;/span&gt; &lt;span class="n"&gt;python3&lt;/span&gt;
&lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Oct&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt; &lt;span class="mi"&gt;2015&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;03&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GCC&lt;/span&gt; &lt;span class="mf"&gt;5.2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;20151010&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;linux&lt;/span&gt;
&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;credits&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;license&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getrecursionlimit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Plots&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_stack_standard.png" /&gt;&lt;/p&gt;
&lt;p&gt;The blue star marks a point of max_stack_depth. Generally, both scatter plots show linear increase in time with a sudden jump in recursive at ~900 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Photo" src="/images/plot_sum_ints_stack_extra.png" /&gt;&lt;/p&gt;
&lt;p&gt;Using the same sys module, I could setrecursionlimit to a higher than default value and explore the difference between recursive and iterative solution on bigger input arrays. As expected, iterative kept winning and recursive suffered another drastic jump in times (~1600), thought the gradient remained linear.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, a simple problem was solved recursively and iteratively. Afterwards, both solutions were benchmarked and analysed in terms of their scalability. &lt;/p&gt;
&lt;p&gt;A recursive solution appears to purists and can be more readable in some cases like tree traversal. In this case, the recursive solution suffered. When combined with the lack of TCO and a relatively low default recursion depth limit value in the CPython interpreter, it proved unscalable and less efficient than iterative. Additionally, wrapping a recusive function introduced a bug, which was absent from the iterative solution.&lt;/p&gt;</summary><category term="algorithms"></category><category term="hackerrank"></category><category term="python"></category></entry><entry><title>mmap vs. ifstream to read a file</title><link href="/mmap-vs-ifstream-to-read-a-file.html" rel="alternate"></link><updated>2017-05-14T18:11:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-05-14:mmap-vs-ifstream-to-read-a-file.html</id><summary type="html">&lt;p&gt;Working on an app that iterates over a huge corpus file line by line made me curious about efficient disk I/O in C++. On each line I need to use the current vector for a calculation that represent words' semantic associations. In this case, the large file is a corpus built from GoogleNews. Each line starts with a word followed by space-separated floats making a 300-dimensional vector finishing with a newline char. The principles should apply for other large files too.&lt;/p&gt;
&lt;p&gt;I am examining different ways of efficiently reading a file from disk line-by-line. Each method described below will run on the same file, surrounded by a timer built from &lt;code&gt;std::chrono&lt;/code&gt; objects as below.&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Profile improved mmap - solving the 2 caveats: iterate over chars in each mapping, and dealing with leftover data in the last mapping.&lt;/li&gt;
&lt;li&gt;Strace analysis&lt;/li&gt;
&lt;li&gt;Assembly analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;steady_clock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;read_file_by_lines&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;steady_clock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; seconds&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;C++ standard&lt;/h2&gt;
&lt;p&gt;The standard C++ way of reading a textfile from disk is by using an input file stream &lt;code&gt;ifstream&lt;/code&gt;. Given a path to file and optional arguments, it creates an input filestream associated with the file at the filename. Then using a for-loop, a line of type std::string is created, as we move the input filestream line-by-line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;read_file_by_lines&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Uses the ifstream from std to open a file given the filename in cur_dir and&lt;/span&gt;
&lt;span class="cm"&gt;   * read it out line-by-line */&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ifstream&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;);)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// uses the \n char in txt file&lt;/span&gt;
    &lt;span class="c1"&gt;// calculation logic&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;mmap txt file&lt;/h2&gt;
&lt;p&gt;The method opens a file descriptor to the filename and starting from the offset of 0, iterates over page_size blocks of memory. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;read_mmaped_file_by_lines&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     mmaps the file into memory by pages (not always aligned with line size).&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
  &lt;span class="c1"&gt;// find filesize using the stat syscall&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;stat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;file_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;page_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// linux page size - 4 KB&lt;/span&gt;
  &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;file_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;page_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PROT_READ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAP_PRIVATE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;page_size&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="c1"&gt;// do stuff with data&lt;/span&gt;
    &lt;span class="n"&gt;munmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;page_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;page_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2 caveats:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the inconvinience of operating on raw bytes of data. There is no getline facility for raw bytes, so you need to iterate over each char in the stream and carry over into next mmaping to join split vectors. eg. if pagebreak comes in the middle of a vector like below&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-0.097343 0.029601 0.058967 0.062243 -0.087515&lt;strong&gt;\n&lt;/strong&gt;with -0.015970 0.014091 &lt;/p&gt;
&lt;p&gt;the newline will be read as well as the next word and its vector values. To avoid losing data we need to carry a std::vector&amp;lt;300&amp;gt; and push_back values into it. Once all values in it aren't equal to the initialisation value, we can write it out with the word into an unordered_map. getline abstracts this away and looks for "/n" char and strips it out. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the filesize isn't a multiple of pagesize (most of the time it's not), we need a special case to manually mmap the last bits&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;mmap bin file&lt;/h2&gt;
&lt;p&gt;Since mmap doesn't care about newline characters (it's all just bytes), we can implement a mmap that takes a binary file and fix the 2 caveats above. &lt;/p&gt;
&lt;h2&gt;Comparison&lt;/h2&gt;
&lt;h3&gt;Time&lt;/h3&gt;
&lt;p&gt;The memory mapped read takes a second longer than the std method.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; clang++-3.7 -Wall -O3 -std&lt;span class="o"&gt;=&lt;/span&gt;c++11 std_read_lines.cpp -o std_read_lines
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./std_read_lines gnews_corpus.txt 

14.8439 seconds
&lt;span class="nv"&gt;$$$$&lt;/span&gt; clang++-3.7 -Wall -O3 -std&lt;span class="o"&gt;=&lt;/span&gt;c++11 mmap_read_lines.cpp -o map_read_lines
&lt;span class="nv"&gt;$$$$&lt;/span&gt; ./map_read_lines gnews_corpus.txt 

16.5109 seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Syscalls&lt;/h3&gt;
&lt;p&gt;Straced both programmes to compare the kind of syscalls they make to investigate potential bottlenecks.&lt;/p&gt;
&lt;h3&gt;Assembly&lt;/h3&gt;
&lt;p&gt;Generated assembly using Godbolt's Compiler Explorer. &lt;a href="https://godbolt.org/g/SRsjN1"&gt;Link&lt;/a&gt;. Need to recompile it first. WIP.&lt;/p&gt;</summary><category term="cpp"></category><category term="linux"></category></entry><entry><title>Debugging hanging elpy on emacs</title><link href="/debugging-hanging-elpy-on-emacs.html" rel="alternate"></link><updated>2017-04-06T22:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-04-06:debugging-hanging-elpy-on-emacs.html</id><summary type="html">&lt;p&gt;I was hacking on a small python script, minding my own business when emacs stopped reacting to my keyboard input. I could still switch windows and work with another applications, but emacs hang up on me. &lt;/p&gt;
&lt;p&gt;Having spent a couple of hours stracing, &lt;a href="/stracing-emacs-part-1.html"&gt;grepping and awking emacs start-up syscalls&lt;/a&gt;, I was in the mood to debug some more. &lt;/p&gt;
&lt;p&gt;Attaching my shell to the pid of emacs (I usually only run 1 emacs instance, hence pgrep emacs). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo strace -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Returns the same error messages repeated.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
pselect6&lt;span class="o"&gt;(&lt;/span&gt;14, &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; 13&lt;span class="o"&gt;]&lt;/span&gt;, &lt;span class="o"&gt;[]&lt;/span&gt;, NULL, &lt;span class="o"&gt;{&lt;/span&gt;0, 19999519&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;NULL, 8&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
poll&lt;span class="o"&gt;([{&lt;/span&gt;&lt;span class="nv"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;7, &lt;span class="nv"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POLLIN&lt;span class="o"&gt;}]&lt;/span&gt;, 1, 0&lt;span class="o"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Timeout&lt;span class="o"&gt;)&lt;/span&gt;
write&lt;span class="o"&gt;(&lt;/span&gt;12, &lt;span class="s2"&gt;&amp;quot;{\&amp;quot;id\&amp;quot;:91,\&amp;quot;method\&amp;quot;:\&amp;quot;get_calltip\&amp;quot;,&amp;quot;&lt;/span&gt;..., 616&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ad nauseum.&lt;/p&gt;
&lt;p&gt;Using the combination of functional programming and bash magic, I nested one function call inside another to get the list of processes. &lt;code&gt;pgrep -P&lt;/code&gt; returns the PIDs of all child processes of a given PID. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; ps -o pid,pcpu,comm -p &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;))&lt;/span&gt;
  PID %CPU COMMAND
&lt;span class="m"&gt;31513&lt;/span&gt;  97.4 python
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is only 1 child process, but it's eating up all the CPU time and killing my battery - it drained 13% in 10 minutes that I was googling and stracing. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;pgrep -P &lt;span class="k"&gt;$(&lt;/span&gt;pgrep emacs&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This made emacs responsive again, so I examined the emacs &lt;em&gt;Messages&lt;/em&gt; buffer&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Wrote /home/petr_tik/Coding/misc/misc/dfs.py
error in process sentinel: elpy-rpc--default-error-callback: peculiar error: &amp;quot;terminated&amp;quot;
error in process sentinel: peculiar error: &amp;quot;terminated&amp;quot;
eldoc error: (file-error Writing to process bad file descriptor  *elpy-rpc [project:~/Coding/misc/misc/ python:/usr/bin/python]*)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/jorgenschaefer/elpy/issues/709"&gt;Here is a relevant GitHub issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Looks like it remains to be solved.&lt;/p&gt;</summary><category term="emacs"></category><category term="python"></category><category term="strace"></category></entry><entry><title>Stracing emacs. Part 1</title><link href="/stracing-emacs-part-1.html" rel="alternate"></link><updated>2017-03-28T23:20:00+01:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-28:stracing-emacs-part-1.html</id><summary type="html">&lt;p&gt;In this series of posts, I investigate and report Emacs start-up procedure and how to optimise it. Emacs is a beautiful OS with a built-in ELisp interpreter and some text editing capabilities. &lt;/p&gt;
&lt;p&gt;I used strace by examining the start up of emacs. &lt;a href="https://github.com/petr-tik/emacs-config"&gt;My emacs config is different&lt;/a&gt; and will be compared to a vanilla emacs start-up. For each syscall I investigated and summarised return values, their frequency to find out how I can improve it. &lt;/p&gt;
&lt;p&gt;I ran the command below, waited until emacs was fully loaded and quit it. -C combines -c with normal output i.e. it printed each syscall, while the process was live and finished the file with the summary table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;strace -C -o emacs_strace_output emacs
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Format&lt;/h2&gt;
&lt;p&gt;I will choose different parameters by which I will choose syscalls to analyse. Then I use the manpage, my favourite search engine (CrouchCrouchWalk) to write up my understanding of the processes.&lt;/p&gt;
&lt;h2&gt;Top 10 by time&lt;/h2&gt;
&lt;p&gt;From the &lt;code&gt;man strace | grep -A 4 sort&lt;/code&gt; page - Strace can sort by time, calls, name, and nothing (default is time). For data consistency, I will use the same output file and awk magic.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; tail -n &lt;span class="m"&gt;69&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; head -n 12
% &lt;span class="nb"&gt;time     &lt;/span&gt;seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 27.05    0.000109           &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;18973&lt;/span&gt;     &lt;span class="m"&gt;17979&lt;/span&gt; open
 23.33    0.000094           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;5192&lt;/span&gt;      &lt;span class="m"&gt;3609&lt;/span&gt; recvmsg
 15.88    0.000064           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;2432&lt;/span&gt;           munmap
 13.65    0.000055           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;3179&lt;/span&gt;           poll
  8.44    0.000034           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;3208&lt;/span&gt;         &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt;
&lt;span class="nb"&gt;  &lt;/span&gt;6.45    0.000026           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;1610&lt;/span&gt;           writev
  2.73    0.000011           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;5127&lt;/span&gt;           lseek
  2.48    0.000010           &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;1005&lt;/span&gt;           close
  0.00    0.000000           &lt;span class="m"&gt;0&lt;/span&gt;        &lt;span class="m"&gt;14&lt;/span&gt;           write
  0.00    0.000000           &lt;span class="m"&gt;0&lt;/span&gt;       &lt;span class="m"&gt;605&lt;/span&gt;       &lt;span class="m"&gt;119&lt;/span&gt; stat
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;open&lt;/h2&gt;
&lt;p&gt;Syscall that usually takes a pointer to const array of chars for pathname and an int for flags. Flags carry information about access modes (read-only, write-only or read-n-write) and file status flags. &lt;/p&gt;
&lt;p&gt;Returns an int that is a file descriptor (non-negative int), which other syscalls in the process will use to access the same file. There is no need to randomly assign fd numbers, so they are given out in ascending order. &lt;/p&gt;
&lt;h4&gt;Errors:&lt;/h4&gt;
&lt;p&gt;Used the magic of grep and awk to extract, count and summarise the number of times each return value (including errors) occured.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep &lt;span class="s2"&gt;&amp;quot;^open&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;)&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;grep "open(" emacs_strace_output&lt;/code&gt;- returns the lines with open syscall trace. "^open(" guarantees that we only examine lines starting with "open"&lt;/p&gt;
&lt;p&gt;&lt;code&gt;awk 'BEGIN { FS=")"} { print $2 }'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Takes the lines and prints column 2 after the ")" separator, which comes at the end of the open syscall. Return values come in different formats&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; -1 ENOENT &lt;span class="o"&gt;(&lt;/span&gt;No such file or directory&lt;span class="o"&gt;)&lt;/span&gt;
 8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we need another awk with a different FS (field separator) variable.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;awk '{ print $2}'&lt;/code&gt; - which uses the default field separator " " and prints the second column, which will be the return value.&lt;/p&gt;
&lt;p&gt;Successful return is a positive int file descriptor, a negative return value can be looked up in the man page for open. Sorting arranges values return values in order, so &lt;code&gt;uniq -c&lt;/code&gt; can summarise and return the count of each value followed by the value. &lt;code&gt;sort -nr&lt;/code&gt; sorts it by numeric value in descending order of counts. &lt;/p&gt;
&lt;p&gt;Below is the end bash one-liner and the resulting table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;count   ret_val&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^open(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;)&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
count   ret_val
  &lt;span class="m"&gt;17979&lt;/span&gt; -1
    &lt;span class="m"&gt;624&lt;/span&gt; 7
    &lt;span class="m"&gt;131&lt;/span&gt; 8
     &lt;span class="m"&gt;86&lt;/span&gt; 3
     &lt;span class="m"&gt;83&lt;/span&gt; 9
     &lt;span class="m"&gt;20&lt;/span&gt; 6
     &lt;span class="m"&gt;15&lt;/span&gt; 4
     &lt;span class="m"&gt;11&lt;/span&gt; 11
     &lt;span class="m"&gt;10&lt;/span&gt; 5
      &lt;span class="m"&gt;6&lt;/span&gt; 10
      &lt;span class="m"&gt;5&lt;/span&gt; 14
      &lt;span class="m"&gt;2&lt;/span&gt; 12
      &lt;span class="m"&gt;1&lt;/span&gt; 13
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As seen in the summary, 17979 open syscalls returned the error value -1, which stands for ENOINT - no such file or directory. Judging by the greatest return value, not more than 14 files are open simultaneously during the start-up process. 18973 - 17979 = 994 and there are 1005 succesful &lt;code&gt;close&lt;/code&gt; syscalls, so 11 times an fd must have been closed and reused. &lt;/p&gt;
&lt;p&gt;Looking at each open syscall with return value 7. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;grep &lt;span class="s2"&gt;&amp;quot;^open&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;\&amp;quot;| &amp;quot; } { print $2,$6 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot; 7&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print $1 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
     &lt;span class="m"&gt;23&lt;/span&gt; /usr/share/icons/default/index.theme
     &lt;span class="m"&gt;12&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/dash-20161121.55/dash-autoloads.el
      &lt;span class="m"&gt;8&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/s-20140714.707/s-autoloads.el
      &lt;span class="m"&gt;6&lt;/span&gt; /usr/share/emacs/24.5/lisp/emacs-lisp/cl-seq.elc
      &lt;span class="m"&gt;6&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/json-snatcher-20150511.2047/json-snatcher-autoloads.el
      &lt;span class="m"&gt;6&lt;/span&gt; /home/petr_tik/.emacs.d/elpa/json-reformat-20160212.53/json-reformat-autoloads.el
      ...
      more filespaths
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shows that several files are repeatedly opened on the same file descriptor. &lt;/p&gt;
&lt;p&gt;Looking at the usr/share/icons/default/index.theme&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep -n &lt;span class="s2"&gt;&amp;quot;usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt; emacs_strace_output 
1530:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 6
3412:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
3446:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
    ...
    more filespaths
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;we take the line numbers where /usr/share/icons/default/index.theme appears and examine a typical case of such a syscall. The first line it is opened under fd 6, so we take the needed number of lines (head for first 1549 lines, out of which we will need the last 20). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;head -n &lt;span class="m"&gt;1535&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 6
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/share/icons/default/index.theme&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 6
fstat&lt;span class="o"&gt;(&lt;/span&gt;6, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;32, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 4096, PROT_READ&lt;span class="p"&gt;|&lt;/span&gt;PROT_WRITE, MAP_PRIVATE&lt;span class="p"&gt;|&lt;/span&gt;MAP_ANONYMOUS, -1, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;6, &lt;span class="s2"&gt;&amp;quot;[Icon Theme]\nInherits=DMZ-White\n&amp;quot;&lt;/span&gt;, 4096&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 32
close&lt;span class="o"&gt;(&lt;/span&gt;6&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 4096&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;after opening the file, emacs runs fstat on the given file descriptor. After that, 4096 bytes of memory is mapped.&lt;/p&gt;
&lt;h2&gt;recvmsg&lt;/h2&gt;
&lt;p&gt;syscall to receive messages from a socket. Came from 4.4BSD (sockets were a BSD invention).&lt;/p&gt;
&lt;p&gt;Input is a socket file descriptor int, pointer to the struct of type msghdr and int for flags. If succesful, they return the length of the receied message. -1 is the error ret value. Summary table shows &amp;gt;3000 error returns, which are investigated below.&lt;/p&gt;
&lt;p&gt;recvmsg uses the pointer to the msghdr struct to minimise the number of arguments. &lt;/p&gt;
&lt;h4&gt;Errors:&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;freq    ret_val&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^recvmsg(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;) &amp;quot;} { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39; { print $2 } &amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
freq    ret_val
   &lt;span class="m"&gt;3609&lt;/span&gt; -1
   &lt;span class="m"&gt;1369&lt;/span&gt; 32
     &lt;span class="m"&gt;97&lt;/span&gt; 224
     &lt;span class="m"&gt;44&lt;/span&gt; 48
     &lt;span class="m"&gt;17&lt;/span&gt; 64
     &lt;span class="m"&gt;17&lt;/span&gt; 40
      &lt;span class="m"&gt;8&lt;/span&gt; 96
      &lt;span class="m"&gt;5&lt;/span&gt; 36
      &lt;span class="m"&gt;4&lt;/span&gt; 128
      &lt;span class="m"&gt;3&lt;/span&gt; 4096
      &lt;span class="m"&gt;3&lt;/span&gt; 1360
      &lt;span class="m"&gt;2&lt;/span&gt; 76
      &lt;span class="m"&gt;2&lt;/span&gt; 160
      &lt;span class="m"&gt;1&lt;/span&gt; 896
      &lt;span class="m"&gt;1&lt;/span&gt; 832
      &lt;span class="m"&gt;1&lt;/span&gt; 56
      &lt;span class="m"&gt;1&lt;/span&gt; 336
      &lt;span class="m"&gt;1&lt;/span&gt; 3348
      &lt;span class="m"&gt;1&lt;/span&gt; 3316
      &lt;span class="m"&gt;1&lt;/span&gt; 268
      &lt;span class="m"&gt;1&lt;/span&gt; 256
      &lt;span class="m"&gt;1&lt;/span&gt; 208
      &lt;span class="m"&gt;1&lt;/span&gt; 1948
      &lt;span class="m"&gt;1&lt;/span&gt; 1236
      &lt;span class="m"&gt;1&lt;/span&gt; 1188
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The number of -1 matches the one 3609 in the summary table confirming that the bash oneliner was correct. The return value is usually the number of bytes read from the socket, which we can expect to be a power of 2. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;   freq socket_descriptor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^recvmsg(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; grep -v &lt;span class="s2"&gt;&amp;quot;= -1&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN { FS=&amp;quot;\\\\(+|,+&amp;quot; } { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
   freq socket_descriptor
   &lt;span class="m"&gt;1583&lt;/span&gt; 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;grep for all recvmsg syscalls, which don't return a -1 error value. NB "\\(" escapes the bracket character and returns the first argument of each recvmsg syscall invocation. uniq -c returns the frequncy for each value. It turned out that emacs listens on only one socket file descriptor (happens to be number 5). Further inspection didn't give too much information.&lt;/p&gt;
&lt;h2&gt;munmap&lt;/h2&gt;
&lt;p&gt;Evil brother of mmap (more info below), which deletes the mappings for the specified address. After that, all references to addresses in that range (addr + length) are invalidated. NB - closing a file descriptor doesn't unmap the region, which means for security you want to close fds and then unmap the region. &lt;/p&gt;
&lt;p&gt;Input:
    pointer of type void to address 
    size_t length&lt;/p&gt;
&lt;p&gt;Returns:
    0 if succesful
    -1 on failure&lt;/p&gt;
&lt;p&gt;mmap - takes more parameters like flags and protection flags, which determine the access rights to those pages. &lt;/p&gt;
&lt;p&gt;Examining output. No errors, just invocation patterns. &lt;/p&gt;
&lt;h5&gt;bash command&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,|\\\\)&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;grep for munmap at the beginning of the line - as before&lt;/li&gt;
&lt;li&gt;awk with 2 field separators comma "," and closing bracket ")"&lt;/li&gt;
&lt;li&gt;print the second column, which will be the size_t var for length of region to unmap. &lt;/li&gt;
&lt;li&gt;sort all occurences of each size_t&lt;/li&gt;
&lt;li&gt;count each uniq value and return a table of counts&lt;/li&gt;
&lt;li&gt;sort the table in descending order&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;   freq  size_t&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,|\\\\)&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c &lt;span class="p"&gt;|&lt;/span&gt; sort -nr
   freq  size_t
   &lt;span class="m"&gt;2067&lt;/span&gt;  69632
    &lt;span class="m"&gt;265&lt;/span&gt;  4096
     &lt;span class="m"&gt;84&lt;/span&gt;  790528
      &lt;span class="m"&gt;5&lt;/span&gt;  117548
      &lt;span class="m"&gt;2&lt;/span&gt;  565248
      &lt;span class="m"&gt;2&lt;/span&gt;  245760
      &lt;span class="m"&gt;2&lt;/span&gt;  2339
      &lt;span class="m"&gt;1&lt;/span&gt;  99000
      &lt;span class="m"&gt;1&lt;/span&gt;  606208
      &lt;span class="m"&gt;1&lt;/span&gt;  475136
      &lt;span class="m"&gt;1&lt;/span&gt;  424408
      &lt;span class="m"&gt;1&lt;/span&gt;  122880
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Funny values of size_t. I found 2339 an interesting value for size_t and deciding to dig into it. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -n &lt;span class="s2"&gt;&amp;quot;^munmap(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;, 2339&amp;quot;&lt;/span&gt;
1016:munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
1023:munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;returns the matched lines with the line number from the original strace_file. So I made a head and tail pipe, which opens the relevant region of the strace output. &lt;a href="https://www.youtube.com/watch?v=Zk5Il6KQrd8"&gt;oh that's a bingo!&lt;/a&gt; - it happens to be the region, when /etc/passwd was opened. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; head -n &lt;span class="m"&gt;1024&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 14
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/etc/passwd&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 4
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 0, SEEK_CUR&lt;span class="o"&gt;)&lt;/span&gt;                   &lt;span class="o"&gt;=&lt;/span&gt; 0
fstat&lt;span class="o"&gt;(&lt;/span&gt;4, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2339, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 2339, PROT_READ, MAP_SHARED, 4, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 2339, SEEK_SET&lt;span class="o"&gt;)&lt;/span&gt;                &lt;span class="o"&gt;=&lt;/span&gt; 2339
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
close&lt;span class="o"&gt;(&lt;/span&gt;4&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/etc/passwd&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 4
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 0, SEEK_CUR&lt;span class="o"&gt;)&lt;/span&gt;                   &lt;span class="o"&gt;=&lt;/span&gt; 0
fstat&lt;span class="o"&gt;(&lt;/span&gt;4, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;st_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;S_IFREG&lt;span class="p"&gt;|&lt;/span&gt;0644, &lt;span class="nv"&gt;st_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2339, ...&lt;span class="o"&gt;})&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0
mmap&lt;span class="o"&gt;(&lt;/span&gt;NULL, 2339, PROT_READ, MAP_SHARED, 4, 0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x7f24722d7000
lseek&lt;span class="o"&gt;(&lt;/span&gt;4, 2339, SEEK_SET&lt;span class="o"&gt;)&lt;/span&gt;                &lt;span class="o"&gt;=&lt;/span&gt; 2339
munmap&lt;span class="o"&gt;(&lt;/span&gt;0x7f24722d7000, 2339&lt;span class="o"&gt;)&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; 0
close&lt;span class="o"&gt;(&lt;/span&gt;4&lt;span class="o"&gt;)&lt;/span&gt;                                &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;poll&lt;/h2&gt;
&lt;p&gt;Similar to select syscall, only newer. ppoll is newer still. Waits for one of a set of fds to come available for IO operations. &lt;/p&gt;
&lt;p&gt;Input:
    pointer to struct of type pollfd - carries the filedescriptor int and requested events
    nfds_t - number of file descriptors to watch
    timeout - milliseconds the syscall can block while waiting for an fd to be ready. It can be interrupted by a signal hanlder. You can set an infinite timeout with a negative value.&lt;/p&gt;
&lt;p&gt;Returns:
    if succesful - positive number of structures with several returned event fields. 
    0 if timed out and/or no fds became ready
    -1 on error&lt;/p&gt;
&lt;h4&gt;Inspecting&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^poll(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot; =&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; { print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot; |=|,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{ print $2 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
     &lt;span class="m"&gt;61&lt;/span&gt; 0
   &lt;span class="m"&gt;3118&lt;/span&gt; 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;61 poll calls timed out. &lt;/p&gt;
&lt;h2&gt;read&lt;/h2&gt;
&lt;p&gt;Tries to read bytes from a given file descriptor into a buffer. &lt;/p&gt;
&lt;p&gt;Gotcha: if count &amp;gt; SSIZE_MAX, the result is unspecified.&lt;/p&gt;
&lt;p&gt;Input:
    file descriptor 
    pointer to buf
    count of type size_t &lt;/p&gt;
&lt;p&gt;Returns:
    if successfully read - returns int number of read bytes, by which the file position is also advanced. The return value may be less than the count (bytes that were requested to read), if a signal interrupts the syscall or we reach EOF. 
    on error, -1 is set to errno. Unspecified if the file position value changes. &lt;/p&gt;
&lt;p&gt;The only error happens when we try to read from the paredit.elc file descriptor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep -n &lt;span class="s2"&gt;&amp;quot;^open(.* = 7\|^read(.* = -1&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; tail -n 2
50481:open&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/home/petr_tik/.emacs.d/elpa/paredit-20140128.1248/paredit.elc&amp;quot;&lt;/span&gt;, O_RDONLY&lt;span class="p"&gt;|&lt;/span&gt;O_CLOEXEC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 7
51237:read&lt;span class="o"&gt;(&lt;/span&gt;7, 0x7fffe3761b80, 16&lt;span class="o"&gt;)&lt;/span&gt;             &lt;span class="o"&gt;=&lt;/span&gt; -1 EAGAIN &lt;span class="o"&gt;(&lt;/span&gt;Resource temporarily unavailable&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;writev&lt;/h2&gt;
&lt;p&gt;Writes given buffers of data to a given file descriptor. Similar to write, but sequentially goes through all the buffers. &lt;/p&gt;
&lt;p&gt;Returns:
    number of bytes written.
    -1 if error&lt;/p&gt;
&lt;h4&gt;Inspecting&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^writev(&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;\\\\(|,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c
   &lt;span class="m"&gt;1610&lt;/span&gt; 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All writev syscalls take file descriptor 5. Is it a coincidence?&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;lseek&lt;/h2&gt;
&lt;p&gt;Given a file descritpor, offset and whence parameters, reposition the offset on the file descriptor. It can move the offset beyond the file size. &lt;/p&gt;
&lt;p&gt;Returns: resulting offset location (in bytes) from the beginning of the file.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;close&lt;/h2&gt;
&lt;p&gt;Does what it says on the tin. Closes a given file desciptor, which allows the int value to be reused. It can return an error and you better check the return value to avoid nasty bugs. It can be interrupted by a signal, in which case it doesn't close the file. Prone to race conditions.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;write&lt;/h2&gt;
&lt;p&gt;writes to a given file descriptor.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h2&gt;stat&lt;/h2&gt;
&lt;p&gt;Like the terminal stat command, returns the status of a file at a given pathname.&lt;/p&gt;
&lt;h4&gt;Errors&lt;/h4&gt;
&lt;p&gt;Confirming that the bash one-liner catches all the errors.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^stat(.* = -1&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; wc -l
119
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now print the list of pathnames that return errors and the ret_values.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$$$$&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;^stat(.* = -&amp;quot;&lt;/span&gt; emacs_strace_output &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;\\\\(\&amp;quot;|\&amp;quot;,| =| &amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; { print $2, $6 }&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Most errors have the value of -1, which according to error section in the &lt;code&gt;man 2 stat&lt;/code&gt; is ENOENT A  component  of  pathname  does  not exist, or pathname is an empty string.&lt;/p&gt;</summary><category term="linux"></category><category term="strace"></category><category term="emacs"></category></entry><entry><title>Puzzles in C++</title><link href="/puzzles-in-c.html" rel="alternate"></link><updated>2017-03-21T19:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-21:puzzles-in-c.html</id><summary type="html">&lt;p&gt;Notes on working with C++, my understanding of the small set of syntax features and data structures available. Might read like obvious or wrong set of assumptions to an experienced C++ engineer. Will keep updating with newer puzzles. &lt;/p&gt;
&lt;h2&gt;Namespaces&lt;/h2&gt;
&lt;p&gt;Define the set of functions, which are used during method name resolution. @jbcoe suggested to avoid it, as it can get messy with several conflicting namespaces.&lt;/p&gt;
&lt;p&gt;Adding this to the top of the file&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;defines where method names will be looked up, which would save 5 chars&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cout&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;instead of &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Data structures&lt;/h2&gt;
&lt;p&gt;Used stringstream object, which inherits from input_ and output_ streams. &lt;/p&gt;
&lt;h2&gt;Misc C++&lt;/h2&gt;
&lt;p&gt;Using clang++, -std=c++11 with awesome features like auto for type inference in for-loops&lt;/p&gt;
&lt;h2&gt;DNA counting puzzle&lt;/h2&gt;
&lt;p&gt;Given a DNA string, return the counts of each char (A, C, G, T). Initial solution - make a map with char as key and count &lt;int&gt; as value. Considering that the structure won't need to grow and we know the full range of characters that can appear, we can optimise. Instead, use an array and an enum to index into the cell in the array. Each value is started at 0 and as we iterate over the string, the value at the relevant index is incremented. That way, we can guarantee using one L1 cache line (4 ints = 16 bytes) and a buffer for the string. For further optimisation, we can implement a streaming buffer, if we are sure the string will only be used once. &lt;/p&gt;</summary><category term="cpp"></category><category term="puzzles"></category><category term="algorithms"></category></entry><entry><title>Notes on python's GC</title><link href="/notes-on-pythons-gc.html" rel="alternate"></link><updated>2017-03-07T23:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-03-07:notes-on-pythons-gc.html</id><summary type="html">&lt;p&gt;Notes on &lt;a href="https://www.youtube.com/watch?v=arxWaw-E8QQ"&gt;Memory Management in Python - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GC is a mechanism for managing memory at runtime. There are several methods including: mark-and-sweep and reference counting. Different language runtimes use different GC mechanisms, each asking for tradeoffs. eg. Java uses mark-and-sweep, which runs less frequently, but the sweep stage 'stops the world' and tidies up. I will be discussing CPython implementation and call it python for brevity (saving a character is very important). There are JPython and IronPython, which rely on JVM and CLR GC mechanisms respectively.&lt;/p&gt;
&lt;h2&gt;Mechanism&lt;/h2&gt;
&lt;p&gt;CPython uses reference counting with an optimisation to eliminate cyclic references, hence slower runtime. Similarly to pointers in C, the variable name is created on the stack and the pointer on the heap. Each created object has a field for storing its reference count - the number of variables that refer to the object. As soon as the refcount falls to 0, the GC collects/tidies up the object.&lt;/p&gt;
&lt;p&gt;Doing simple reference counting is prone to not deleting cyclically referenced objects. eg. If Object A refers to Object B and Object B to Object A, they will never get collected using simple reference counting (both will always have a ref count of at least 1). &lt;/p&gt;
&lt;h3&gt;Difference between py2 and py3 gc.&lt;/h3&gt;
&lt;p&gt;Python3 has a get_stats() method, which returns a list of dictionaries containing per-generation statistics. &lt;/p&gt;
&lt;h3&gt;Interacting&lt;/h3&gt;
&lt;p&gt;THere is a builtin module called gc, which allows you to enable, disable or run GC at any point in your programme. Some explanations that I read say you can change the number of generations, yet I can't find a method for that. The gc.set_threshold() command throws a "TypeError:  takes at most 3 arguments (4 given)". &lt;/p&gt;
&lt;h2&gt;Optimisations/heuristics&lt;/h2&gt;
&lt;h3&gt;Generations&lt;/h3&gt;
&lt;p&gt;All objects are split into 3 exclusive generations. The idea behind it is that objects won't live long, so younger generations are GC'ed more often than older generations. Generation 0 is where the newly created object lives, until it's spent enough time to be promoted. &lt;/p&gt;
&lt;h3&gt;Global value reuse&lt;/h3&gt;
&lt;p&gt;When a new variable (reference) is created, the python runtime checks if an object with such a value already exists. If it does, the new variable doesn't create a reference, instead it increases the refcount of int_object with value 10 to 2 as below. This works either when the object a new object is created or a primitive object's value is changed to match the value of an already existing object.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python creates an int object on the heap. If a new variable is created on the stack and assigned to a value, python sets up a reference between the new variable and the already existing object. &lt;/p&gt;</summary><category term="python"></category><category term="gc"></category><category term="memory"></category></entry><entry><title>CI for Solent-eng</title><link href="/ci-for-solent-eng.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:ci-for-solent-eng.html</id><summary type="html">&lt;p&gt;Spent the day working on a plan to build custom CI pipeline for &lt;a href="https://github.com/solent-eng/solent"&gt;solent&lt;/a&gt;. The design encourages and relies on GitHub-workflow using Pull Requests for all changes - even small ones made by the creator/admin. Will run test suites on different VMs and only allow PR to be merged, if all tests pass. Adding a new VM (for BSD, OSX, minix or other platform) should be: 1) easy, 2) independent of others and independent of the code on master.&lt;/p&gt;
&lt;h2&gt;Pull Request workflow&lt;/h2&gt;
&lt;p&gt;As an OSS project developed in 2017, Solent-eng should have a contributor-friendly way of reviewing issues, pushing changes and testing code. Using the GitHub webhook API, an event loop will notify the master slave of all changes to any Pull Requests (new or existing). This combined with the repo settings preventing from direct pushes to master will make everyone's commits go through the CI suite. This will also apply for the admin, as he is equally human and can make mistakes. Such culture of testing early, often and meritocratically, will help maintain the quality of code with hopefully few regressions. &lt;/p&gt;
&lt;h2&gt;CI master server&lt;/h2&gt;
&lt;p&gt;Lives on a VM in the cloud. In charge of listening to GitHub hooks, keeps a queue of jobs. Starts and monitors OS-specific VMs that run the test suite as of a given commit. Communicates the outcome of all test runners to the GitHub commit's status API.&lt;/p&gt;
&lt;h2&gt;GitHub webhook&lt;/h2&gt;
&lt;p&gt;A server will listen to events from the GitHub webhook, which in their payload will carry the refs and commit hashes of the PR. Initially, we will consider 3 scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New pull request&lt;/li&gt;
&lt;li&gt;Changes to a currently open PR&lt;/li&gt;
&lt;li&gt;Closed and merged a Pull Request&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;New PR or changes to current PR&lt;/h3&gt;
&lt;p&gt;First prototype - tear down current VMs of out-of-date commit hash. Start a new set of VMs with the new commit.&lt;/p&gt;
&lt;p&gt;Long-term plan: add the new commit hash to the job queue. Run all suites for all commits. &lt;/p&gt;
&lt;h3&gt;Closed and merged a Pull Request&lt;/h3&gt;
&lt;p&gt;Each test VM, if test suite exits with 0 errors, should build its executable. The CI master will tell each VM to upload the artefact to a location. TODO: hardwire the address inside the VM test runner or pass it as part of the request from the master.&lt;/p&gt;
&lt;h2&gt;Test suite VMs&lt;/h2&gt;
&lt;p&gt;Plans to support linux, BSD, OSX and Windows. All test suites will be run in VMs either in the cloud or on-premises. If tests fail, logs of terminal output should be forwarded to master. TODO: decide how CI-master will show it to GitHub users.&lt;/p&gt;</summary><category term="python"></category><category term="solent"></category><category term="ci"></category></entry><entry><title>Unexpected bfs</title><link href="/unexpected-bfs.html" rel="alternate"></link><updated>2017-02-27T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2017-02-27:unexpected-bfs.html</id><summary type="html">&lt;p&gt;This &lt;a href="https://www.hackerrank.com/challenges/candies"&gt;puzzle&lt;/a&gt; is in the DP section of HackerRank. With DP, you expect a recursive solution is expected, which is less memory efficient. Therefore, you should find a way to memoize/cache results of previous calculations to make it pass. &lt;/p&gt;
&lt;h2&gt;Problem statement:&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Given an array of students&amp;#39; grades (ints) in the same order as they sit. Return the minimal number of candies all students receive, such that:
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;out of 2 adjacent students, the one with a higher grade receives more candy&lt;/li&gt;
&lt;li&gt;each student receives at least 1 piece of candy&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Plot twist&lt;/h3&gt;
&lt;p&gt;Alternatively, you can look at the problem as a graph theory problem. &lt;/p&gt;
&lt;p&gt;Represent each student as a node on a plane. Among adjacent nodes, draw directed edges from the node with a lower grade to the node with a higher grade. All the nodes without incoming edges aren't greater than their neighbours (equal grades means you can give less candy), so they will receive the minimum amount - 1. Now start several breadth-first searches from each of the nodes without incoming edges (they will be the local start points). Visit node and increment the value at its index in the candies array. Differently to normal breadth-first search, you don't need to keep track of previously visited nodes and you can revisit them to increment the counter. In case you have a peak around a point 8 (index = 3) eg&lt;/p&gt;
&lt;p&gt;grades
1 2 4 8 6 5 3 2 1&lt;/p&gt;
&lt;p&gt;candies (illegal) - if you don't revisit nodes to update counter. 
1 2 3 4 5 4 3 2 1 &lt;/p&gt;
&lt;p&gt;candies (solution)
1 2 3 6 5 4 3 2 1&lt;/p&gt;
&lt;h3&gt;Complexity&lt;/h3&gt;
&lt;p&gt;The prepare_for_bfs method takes linear O(n) time and bfs takes maximum O(V + E)&lt;/p&gt;
&lt;p&gt;The code is &lt;a href="https://github.com/petr-tik/misc/blob/master/candies.py"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you see a problem in description or the code, please open issues, send PRs&lt;/p&gt;</summary><category term="python"></category><category term="algorithms"></category><category term="hackerrank"></category></entry><entry><title>Getting clojure with Lisp</title><link href="/getting-clojure-with-lisp.html" rel="alternate"></link><updated>2016-02-20T10:20:00+00:00</updated><author><name>Petr Tikilyaynen</name></author><id>tag:,2016-02-20:getting-clojure-with-lisp.html</id><summary type="html">&lt;p&gt;I have spent the weekend reading and getting my head around Clojure and here are my first thoughts.&lt;/p&gt;
&lt;p&gt;It's definitely a great exercise and even if I will never get to write a single line of code in a functional language in my life, I will be more confident using map, filter and reduce in python. &lt;/p&gt;
&lt;p&gt;Adopting the immutable data approach, makes me really concentrate on the quality and good compositionality of the functions, where I really think through how to make a series of pure functions, whose output will feed into the next one's input well. WHile REPL-based development is helpful to try defn functions on the fly to experiment, my python background is annoyed that I cannot just print the state of the programme at every step: 
i) pure functions are stateless
ii) pure functions have no side effect like printing to the stdout&lt;/p&gt;
&lt;p&gt;As this is an exercise in thinking and writing pure functions, printing to stdout is betraying the clojure way and would involve a helper function that needs to wrap each function and print the arguments and output. &lt;/p&gt;
&lt;p&gt;Going forward, I've been told 4Clojure is a good source of problems and the TDD framework is very thorough. Another upside of pure functions I hope to experience soon is the ease of unit testing them. If you write all helper functions and main the UNIX way, you should be able to test each of them separately and when composed with easy input. &lt;/p&gt;
&lt;p&gt;A good exercise, which lends itself nicely to Clojure is checking if a given word and any word from a vector of words have are anagrams. &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagram?&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes 2 words - returns True if they are anagrams, false otherwise&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;word1&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frequencies&lt;/span&gt; &lt;span class="nv"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;true&lt;/span&gt;
        &lt;span class="nv"&gt;false&lt;/span&gt;
        &lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;anagrams&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Takes a target word and a vector of words &lt;/span&gt;
&lt;span class="s"&gt;Returns a list of anagrams of the target from the vector&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;anagram?&lt;/span&gt; &lt;span class="nv"&gt;target-word&lt;/span&gt; &lt;span class="nv"&gt;candidate-word&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;list-of-words&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="clojure"></category></entry></feed>