<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Stracing emacs. Part 1 // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Stracing emacs. Part 1</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/linux.html">linux</a>
                                <a class="post-category" href="/tag/tracing.html">tracing</a>
                                <a class="post-category" href="/tag/emacs.html">emacs</a>
                        </p>
                </header>
            </section>
            <p>In this series of posts, I investigate and report Emacs start-up procedure and how to optimise it. Emacs is a beautiful OS with a built-in ELisp interpreter and some text editing capabilities. </p>
<p>I used strace by examining the start up of emacs. <a href="https://github.com/petr-tik/emacs-config">My emacs config is different</a> and will be compared to a vanilla emacs start-up. For each syscall I investigated and summarised return values, their frequency to find out how I can improve it. </p>
<p>I ran the command below, waited until emacs was fully loaded and quit it. -C combines -c with normal output i.e. it printed each syscall, while the process was live and finished the file with the summary table.</p>
<div class="highlight"><pre>strace -C -o emacs_strace_output emacs
</pre></div>


<h2>Format</h2>
<p>I will choose different parameters by which I will choose syscalls to analyse. Then I use the manpage, my favourite search engine (CrouchCrouchWalk) to write up my understanding of the processes.</p>
<h2>Top 10 by time</h2>
<p>From the <code>man strace | grep -A 4 sort</code> page - Strace can sort by time, calls, name, and nothing (default is time). For data consistency, I will use the same output file and awk magic.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> tail -n <span class="m">69</span> emacs_strace_output <span class="p">|</span> head -n 12
% <span class="nb">time     </span>seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 27.05    0.000109           <span class="m">0</span>     <span class="m">18973</span>     <span class="m">17979</span> open
 23.33    0.000094           <span class="m">0</span>      <span class="m">5192</span>      <span class="m">3609</span> recvmsg
 15.88    0.000064           <span class="m">0</span>      <span class="m">2432</span>           munmap
 13.65    0.000055           <span class="m">0</span>      <span class="m">3179</span>           poll
  8.44    0.000034           <span class="m">0</span>      <span class="m">3208</span>         <span class="m">1</span> <span class="nb">read</span>
<span class="nb">  </span>6.45    0.000026           <span class="m">0</span>      <span class="m">1610</span>           writev
  2.73    0.000011           <span class="m">0</span>      <span class="m">5127</span>           lseek
  2.48    0.000010           <span class="m">0</span>      <span class="m">1005</span>           close
  0.00    0.000000           <span class="m">0</span>        <span class="m">14</span>           write
  0.00    0.000000           <span class="m">0</span>       <span class="m">605</span>       <span class="m">119</span> stat
</pre></div>


<h2>open</h2>
<p>Syscall that usually takes a pointer to const array of chars for pathname and an int for flags. Flags carry information about access modes (read-only, write-only or read-n-write) and file status flags. </p>
<p>Returns an int that is a file descriptor (non-negative int), which other syscalls in the process will use to access the same file. There is no need to randomly assign fd numbers, so they are given out in ascending order. </p>
<h4>Errors:</h4>
<p>Used the magic of grep and awk to extract, count and summarise the number of times each return value (including errors) occured.</p>
<div class="highlight"><pre>grep <span class="s2">&quot;^open&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;)&quot; } { print $2 }&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
</pre></div>


<p><code>grep "open(" emacs_strace_output</code>- returns the lines with open syscall trace. "^open(" guarantees that we only examine lines starting with "open"</p>
<p><code>awk 'BEGIN { FS=")"} { print $2 }'</code></p>
<p>Takes the lines and prints column 2 after the ")" separator, which comes at the end of the open syscall. Return values come in different formats</p>
<div class="highlight"><pre> -1 ENOENT <span class="o">(</span>No such file or directory<span class="o">)</span>
 8
</pre></div>


<p>So we need another awk with a different FS (field separator) variable.</p>
<p><code>awk '{ print $2}'</code> - which uses the default field separator " " and prints the second column, which will be the return value.</p>
<p>Successful return is a positive int file descriptor, a negative return value can be looked up in the man page for open. Sorting arranges values return values in order, so <code>uniq -c</code> can summarise and return the count of each value followed by the value. <code>sort -nr</code> sorts it by numeric value in descending order of counts. </p>
<p>Below is the end bash one-liner and the resulting table.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> <span class="nb">echo</span> <span class="s2">&quot;count   ret_val&quot;</span><span class="p">;</span> grep <span class="s2">&quot;^open(&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;)&quot; } { print $2 }&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
count   ret_val
  <span class="m">17979</span> -1
    <span class="m">624</span> 7
    <span class="m">131</span> 8
     <span class="m">86</span> 3
     <span class="m">83</span> 9
     <span class="m">20</span> 6
     <span class="m">15</span> 4
     <span class="m">11</span> 11
     <span class="m">10</span> 5
      <span class="m">6</span> 10
      <span class="m">5</span> 14
      <span class="m">2</span> 12
      <span class="m">1</span> 13
</pre></div>


<p>As seen in the summary, 17979 open syscalls returned the error value -1, which stands for ENOINT - no such file or directory. Judging by the greatest return value, not more than 14 files are open simultaneously during the start-up process. 18973 - 17979 = 994 and there are 1005 succesful <code>close</code> syscalls, so 11 times an fd must have been closed and reused. </p>
<p>Looking at each open syscall with return value 7. </p>
<div class="highlight"><pre><span class="nv">$$$ </span>grep <span class="s2">&quot;^open&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;\&quot;| &quot; } { print $2,$6 }&#39;</span> <span class="p">|</span> grep <span class="s2">&quot; 7&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
     <span class="m">23</span> /usr/share/icons/default/index.theme
     <span class="m">12</span> /home/petr_tik/.emacs.d/elpa/dash-20161121.55/dash-autoloads.el
      <span class="m">8</span> /home/petr_tik/.emacs.d/elpa/s-20140714.707/s-autoloads.el
      <span class="m">6</span> /usr/share/emacs/24.5/lisp/emacs-lisp/cl-seq.elc
      <span class="m">6</span> /home/petr_tik/.emacs.d/elpa/json-snatcher-20150511.2047/json-snatcher-autoloads.el
      <span class="m">6</span> /home/petr_tik/.emacs.d/elpa/json-reformat-20160212.53/json-reformat-autoloads.el
      ...
      more filespaths
</pre></div>


<p>shows that several files are repeatedly opened on the same file descriptor. </p>
<p>Looking at the usr/share/icons/default/index.theme</p>
<div class="highlight"><pre><span class="nv">$$$$</span> grep -n <span class="s2">&quot;usr/share/icons/default/index.theme&quot;</span> emacs_strace_output 
1530:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 6
3412:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 7
3446:open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 7
    ...
    more filespaths
</pre></div>


<p>we take the line numbers where /usr/share/icons/default/index.theme appears and examine a typical case of such a syscall. The first line it is opened under fd 6, so we take the needed number of lines (head for first 1549 lines, out of which we will need the last 20). </p>
<div class="highlight"><pre><span class="nv">$$$ </span>head -n <span class="m">1535</span> emacs_strace_output <span class="p">|</span> tail -n 6
open<span class="o">(</span><span class="s2">&quot;/usr/share/icons/default/index.theme&quot;</span>, O_RDONLY<span class="o">)</span> <span class="o">=</span> 6
fstat<span class="o">(</span>6, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0644, <span class="nv">st_size</span><span class="o">=</span>32, ...<span class="o">})</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 4096, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_ANONYMOUS, -1, 0<span class="o">)</span> <span class="o">=</span> 0x7f24722d7000
<span class="nb">read</span><span class="o">(</span>6, <span class="s2">&quot;[Icon Theme]\nInherits=DMZ-White\n&quot;</span>, 4096<span class="o">)</span> <span class="o">=</span> 32
close<span class="o">(</span>6<span class="o">)</span>                                <span class="o">=</span> 0
munmap<span class="o">(</span>0x7f24722d7000, 4096<span class="o">)</span>            <span class="o">=</span> 0
</pre></div>


<p>after opening the file, emacs runs fstat on the given file descriptor. After that, 4096 bytes of memory is mapped.</p>
<h2>recvmsg</h2>
<p>syscall to receive messages from a socket. Came from 4.4BSD (sockets were a BSD invention).</p>
<p>Input is a socket file descriptor int, pointer to the struct of type msghdr and int for flags. If succesful, they return the length of the receied message. -1 is the error ret value. Summary table shows &gt;3000 error returns, which are investigated below.</p>
<p>recvmsg uses the pointer to the msghdr struct to minimise the number of arguments. </p>
<h4>Errors:</h4>
<div class="highlight"><pre><span class="nv">$$$ </span><span class="nb">echo</span> <span class="s2">&quot;freq    ret_val&quot;</span><span class="p">;</span> grep <span class="s2">&quot;^recvmsg(&quot;</span> emacs_strace_output <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;) &quot;} { print $2 }&#39;</span> <span class="p">|</span> awk <span class="s1">&#39; { print $2 } &#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
freq    ret_val
   <span class="m">3609</span> -1
   <span class="m">1369</span> 32
     <span class="m">97</span> 224
     <span class="m">44</span> 48
     <span class="m">17</span> 64
     <span class="m">17</span> 40
      <span class="m">8</span> 96
      <span class="m">5</span> 36
      <span class="m">4</span> 128
      <span class="m">3</span> 4096
      <span class="m">3</span> 1360
      <span class="m">2</span> 76
      <span class="m">2</span> 160
      <span class="m">1</span> 896
      <span class="m">1</span> 832
      <span class="m">1</span> 56
      <span class="m">1</span> 336
      <span class="m">1</span> 3348
      <span class="m">1</span> 3316
      <span class="m">1</span> 268
      <span class="m">1</span> 256
      <span class="m">1</span> 208
      <span class="m">1</span> 1948
      <span class="m">1</span> 1236
      <span class="m">1</span> 1188
</pre></div>


<p>The number of -1 matches the one 3609 in the summary table confirming that the bash oneliner was correct. The return value is usually the number of bytes read from the socket, which we can expect to be a power of 2. </p>
<div class="highlight"><pre><span class="nv">$$$$</span> <span class="nb">echo</span> <span class="s2">&quot;   freq socket_descriptor&quot;</span><span class="p">;</span> grep <span class="s2">&quot;^recvmsg(&quot;</span> emacs_strace_output <span class="p">|</span> grep -v <span class="s2">&quot;= -1&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;BEGIN { FS=&quot;\\\\(+|,+&quot; } { print $2 }&#39;</span> <span class="p">|</span> uniq -c
   freq socket_descriptor
   <span class="m">1583</span> 5
</pre></div>


<p>grep for all recvmsg syscalls, which don't return a -1 error value. NB "\\(" escapes the bracket character and returns the first argument of each recvmsg syscall invocation. uniq -c returns the frequncy for each value. It turned out that emacs listens on only one socket file descriptor (happens to be number 5). Further inspection didn't give too much information.</p>
<h2>munmap</h2>
<p>Evil brother of mmap (more info below), which deletes the mappings for the specified address. After that, all references to addresses in that range (addr + length) are invalidated. NB - closing a file descriptor doesn't unmap the region, which means for security you want to close fds and then unmap the region. </p>
<p>Input:
    pointer of type void to address 
    size_t length</p>
<p>Returns:
    0 if succesful
    -1 on failure</p>
<p>mmap - takes more parameters like flags and protection flags, which determine the access rights to those pages. </p>
<p>Examining output. No errors, just invocation patterns. </p>
<h5>bash command</h5>
<div class="highlight"><pre><span class="nv">$$$$</span> grep <span class="s2">&quot;^munmap(&quot;</span> emacs_strace_output <span class="p">|</span> awk -F<span class="s2">&quot;,|\\\\)&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
</pre></div>


<ol>
<li>grep for munmap at the beginning of the line - as before</li>
<li>awk with 2 field separators comma "," and closing bracket ")"</li>
<li>print the second column, which will be the size_t var for length of region to unmap. </li>
<li>sort all occurences of each size_t</li>
<li>count each uniq value and return a table of counts</li>
<li>sort the table in descending order</li>
</ol>
<div class="highlight"><pre><span class="nv">$$$$</span> <span class="nb">echo</span> <span class="s2">&quot;   freq  size_t&quot;</span><span class="p">;</span> grep <span class="s2">&quot;^munmap(&quot;</span> emacs_strace_output <span class="p">|</span> awk -F<span class="s2">&quot;,|\\\\)&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr
   freq  size_t
   <span class="m">2067</span>  69632
    <span class="m">265</span>  4096
     <span class="m">84</span>  790528
      <span class="m">5</span>  117548
      <span class="m">2</span>  565248
      <span class="m">2</span>  245760
      <span class="m">2</span>  2339
      <span class="m">1</span>  99000
      <span class="m">1</span>  606208
      <span class="m">1</span>  475136
      <span class="m">1</span>  424408
      <span class="m">1</span>  122880
</pre></div>


<p>Funny values of size_t. I found 2339 an interesting value for size_t and deciding to dig into it. </p>
<div class="highlight"><pre>grep -n <span class="s2">&quot;^munmap(&quot;</span> emacs_strace_output <span class="p">|</span> grep <span class="s2">&quot;, 2339&quot;</span>
1016:munmap<span class="o">(</span>0x7f24722d7000, 2339<span class="o">)</span>            <span class="o">=</span> 0
1023:munmap<span class="o">(</span>0x7f24722d7000, 2339<span class="o">)</span>            <span class="o">=</span> 0
</pre></div>


<p>returns the matched lines with the line number from the original strace_file. So I made a head and tail pipe, which opens the relevant region of the strace output. <a href="https://www.youtube.com/watch?v=Zk5Il6KQrd8">oh that's a bingo!</a> - it happens to be the region, when /etc/passwd was opened. </p>
<div class="highlight"><pre><span class="nv">$$$$</span> head -n <span class="m">1024</span> emacs_strace_output <span class="p">|</span> tail -n 14
open<span class="o">(</span><span class="s2">&quot;/etc/passwd&quot;</span>, O_RDONLY<span class="p">|</span>O_CLOEXEC<span class="o">)</span> <span class="o">=</span> 4
lseek<span class="o">(</span>4, 0, SEEK_CUR<span class="o">)</span>                   <span class="o">=</span> 0
fstat<span class="o">(</span>4, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0644, <span class="nv">st_size</span><span class="o">=</span>2339, ...<span class="o">})</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 2339, PROT_READ, MAP_SHARED, 4, 0<span class="o">)</span> <span class="o">=</span> 0x7f24722d7000
lseek<span class="o">(</span>4, 2339, SEEK_SET<span class="o">)</span>                <span class="o">=</span> 2339
munmap<span class="o">(</span>0x7f24722d7000, 2339<span class="o">)</span>            <span class="o">=</span> 0
close<span class="o">(</span>4<span class="o">)</span>                                <span class="o">=</span> 0
open<span class="o">(</span><span class="s2">&quot;/etc/passwd&quot;</span>, O_RDONLY<span class="p">|</span>O_CLOEXEC<span class="o">)</span> <span class="o">=</span> 4
lseek<span class="o">(</span>4, 0, SEEK_CUR<span class="o">)</span>                   <span class="o">=</span> 0
fstat<span class="o">(</span>4, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0644, <span class="nv">st_size</span><span class="o">=</span>2339, ...<span class="o">})</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 2339, PROT_READ, MAP_SHARED, 4, 0<span class="o">)</span> <span class="o">=</span> 0x7f24722d7000
lseek<span class="o">(</span>4, 2339, SEEK_SET<span class="o">)</span>                <span class="o">=</span> 2339
munmap<span class="o">(</span>0x7f24722d7000, 2339<span class="o">)</span>            <span class="o">=</span> 0
close<span class="o">(</span>4<span class="o">)</span>                                <span class="o">=</span> 0
</pre></div>


<h2>poll</h2>
<p>Similar to select syscall, only newer. ppoll is newer still. Waits for one of a set of fds to come available for IO operations. </p>
<p>Input:
    pointer to struct of type pollfd - carries the filedescriptor int and requested events
    nfds_t - number of file descriptors to watch
    timeout - milliseconds the syscall can block while waiting for an fd to be ready. It can be interrupted by a signal hanlder. You can set an infinite timeout with a negative value.</p>
<p>Returns:
    if succesful - positive number of structures with several returned event fields. 
    0 if timed out and/or no fds became ready
    -1 on error</p>
<h4>Inspecting</h4>
<div class="highlight"><pre><span class="nv">$$$$</span> grep <span class="s2">&quot;^poll(&quot;</span> emacs_strace_output <span class="p">|</span> awk -F<span class="s2">&quot; =&quot;</span> <span class="s1">&#39; { print $2 }&#39;</span> <span class="p">|</span> awk -F<span class="s2">&quot; |=|,&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c
     <span class="m">61</span> 0
   <span class="m">3118</span> 1
</pre></div>


<p>61 poll calls timed out. </p>
<h2>read</h2>
<p>Tries to read bytes from a given file descriptor into a buffer. </p>
<p>Gotcha: if count &gt; SSIZE_MAX, the result is unspecified.</p>
<p>Input:
    file descriptor 
    pointer to buf
    count of type size_t </p>
<p>Returns:
    if successfully read - returns int number of read bytes, by which the file position is also advanced. The return value may be less than the count (bytes that were requested to read), if a signal interrupts the syscall or we reach EOF. 
    on error, -1 is set to errno. Unspecified if the file position value changes. </p>
<p>The only error happens when we try to read from the paredit.elc file descriptor.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> grep -n <span class="s2">&quot;^open(.* = 7\|^read(.* = -1&quot;</span> emacs_strace_output <span class="p">|</span> tail -n 2
50481:open<span class="o">(</span><span class="s2">&quot;/home/petr_tik/.emacs.d/elpa/paredit-20140128.1248/paredit.elc&quot;</span>, O_RDONLY<span class="p">|</span>O_CLOEXEC<span class="o">)</span> <span class="o">=</span> 7
51237:read<span class="o">(</span>7, 0x7fffe3761b80, 16<span class="o">)</span>             <span class="o">=</span> -1 EAGAIN <span class="o">(</span>Resource temporarily unavailable<span class="o">)</span>
</pre></div>


<h2>writev</h2>
<p>Writes given buffers of data to a given file descriptor. Similar to write, but sequentially goes through all the buffers. </p>
<p>Returns:
    number of bytes written.
    -1 if error</p>
<h4>Inspecting</h4>
<div class="highlight"><pre><span class="nv">$$$$</span> grep <span class="s2">&quot;^writev(&quot;</span> emacs_strace_output <span class="p">|</span> awk -F<span class="s2">&quot;\\\\(|,&quot;</span> <span class="s1">&#39; {print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c
   <span class="m">1610</span> 5
</pre></div>


<p>All writev syscalls take file descriptor 5. Is it a coincidence?</p>
<h4>Errors</h4>
<p>None</p>
<h2>lseek</h2>
<p>Given a file descritpor, offset and whence parameters, reposition the offset on the file descriptor. It can move the offset beyond the file size. </p>
<p>Returns: resulting offset location (in bytes) from the beginning of the file.</p>
<h4>Errors</h4>
<p>None</p>
<h2>close</h2>
<p>Does what it says on the tin. Closes a given file desciptor, which allows the int value to be reused. It can return an error and you better check the return value to avoid nasty bugs. It can be interrupted by a signal, in which case it doesn't close the file. Prone to race conditions.</p>
<h4>Errors</h4>
<p>None</p>
<h2>write</h2>
<p>writes to a given file descriptor.</p>
<h4>Errors</h4>
<p>None</p>
<h2>stat</h2>
<p>Like the terminal stat command, returns the status of a file at a given pathname.</p>
<h4>Errors</h4>
<p>Confirming that the bash one-liner catches all the errors.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> grep <span class="s2">&quot;^stat(.* = -1&quot;</span> emacs_strace_output <span class="p">|</span> wc -l
119
</pre></div>


<p>Now print the list of pathnames that return errors and the ret_values.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> grep <span class="s2">&quot;^stat(.* = -&quot;</span> emacs_strace_output <span class="p">|</span> awk -F<span class="s2">&quot;\\\\(\&quot;|\&quot;,| =| &quot;</span> <span class="s1">&#39; { print $2, $6 }&#39;</span> <span class="p">|</span> sort
</pre></div>


<p>Most errors have the value of -1, which according to error section in the <code>man 2 stat</code> is ENOENT A  component  of  pathname  does  not exist, or pathname is an empty string.</p>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>