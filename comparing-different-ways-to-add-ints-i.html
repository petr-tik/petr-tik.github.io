<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Comparing different ways to add ints I // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Comparing different ways to add ints I</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/algorithms.html">algorithms</a>
                                <a class="post-category" href="/tag/hackerrank.html">hackerrank</a>
                                <a class="post-category" href="/tag/python.html">python</a>
                        </p>
                </header>
            </section>
            <h2>Puzzle</h2>
<p>Given 2 ints represented as array of digits in order (eg. 843 = [8, 4, 3]), implement a function that returns a sum of the 2 ints in the same format.</p>
<p>eg. </p>
<p>[8, 4, 3] + [1, 8, 2] = [1, 0, 2, 5]</p>
<h2>Idea</h2>
<p>Implement and profile recursive and iterative solutions to the puzzle above.</p>
<h3>Recursive solution</h3>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="p">[],</span> <span class="n">carry</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># guarantee it doesn&#39;t change array outside func scope</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>

    <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">carry</span><span class="p">)</span>
</pre></div>


<p>Having done some Clojure, functional tools like map and reduce made it feel that a recursive solution was going to be concise. Handling the same edge cases across different array lengths made the implementation more heavily branched and less pretty than expected.</p>
<p>The final return statement will activate once idx exhausts both arrays (i.e. incremented beyond both lengths). If the carry bit has been carried over from the previous stack frame, which called this last stack frame, add 1 to the end of the array and return the result. </p>
<p>Otherwise, if either of the arrays is exhausted, add the ints from the other array keeping carry bit in mind. All 3 cases (arr1 - exhausted, arr2 - not; arr2 - exhaused, arr1 - not; arr1 and arr2 still not exhausted) use divmod function to set the carry bit and item_to_add. On Intel CPUs this should happen in 1 instruction. The only difference is using both arrays if both are still not exhausted.</p>
<h3>Iterative solution</h3>
<p>Unrolls the recursive loop. Instead of creating a stack frame for each digit, add as many digits as possible before one of the arrays runs out, then handle the leftover digits from the longer array. In the case of arrays/numbers of the same length, there won't be any branch misprediction and we will fall through down to the return statement.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">iter_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">)):</span>
        <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">):</span>
            <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
            <span class="n">carry</span><span class="p">,</span> <span class="n">item_to_add</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">carry</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_add</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>


<h3>Wrapper to time each function call</h3>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">timeit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">elapsedTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span>
        <span class="n">time_as_string</span> <span class="o">=</span> <span class="s1">&#39;{:.6f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsedTime</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">time_as_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfunc</span>
</pre></div>


<p>This takes the wrapped function, passes the original args, times how long it took to execute and returns a tuple of function return value and time_as_string.</p>
<div class="highlight"><pre><span></span><span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">iter_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
</pre></div>


<p>For a fair comparison, both should have the same design and stack allocation strategy. Hence both iter_sum and recur_sum methods reverse the incoming arrays and return the result of the helper. The iterative method calculates everything in 1 stack frame. The recursive recur_sum_helper (by definition) creates a stack frame for each call. </p>
<p>As both _sum methods prepare and pass reversed arrays into helper methods, the helper methods return the result array in the opposite order. Both _sum methods reverse the return arrays before returning.</p>
<h4>Bug</h4>
<p>In the first version of the recur_sum_helper and wrapper there was a bug - the recursive solution returned an array much longer than expected. This was the wrapper's fault, as was proven by running the methods without wrapping and stepping through it with pdb. </p>
<p>The timeit wrapper method tooks the args and kwargs of the wrappee and kept them across runs. From the second interation onwards, the res array in the wrapped recur_sum_helper was kept inside the wrapper. Python variables are references, so after the res variable was created inside the scope of the wrapper, following <code>res.append</code> calls grew the same res array as before. </p>
<p>Adding</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recur_sum_helper</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="p">[],</span> <span class="n">carry</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</pre></div>


<p>solved the problem by creating a new array.</p>
<h2>Performance comparison</h2>
<p>Using the script below, the wrapper described above, recursive and iterative solutions were benchmarked. The plots below show show time on the y-axis against the size of 2 input arrays on the x-axis. Green points - recursive times, red - iterative, blue star is the stack length of the array at which stack overflows. Catching stack overflow at runtime has to be done with a try/except loop, which breaks on RuntimeError. </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">try_different_lengths_before_breaks</span><span class="p">(</span><span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">,</span> <span class="n">py_stack_limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">py_stack_limit</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="n">py_stack_limit</span><span class="p">)</span>
    <span class="n">iter_arr_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">recur_arr_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">iter_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">recur_times</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">arr_length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r_limit</span><span class="p">,</span> <span class="n">l_limit</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)]</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)]</span>
        <span class="c1"># good test case, because there will be a carry bit over every step</span>
        <span class="n">res_iter</span><span class="p">,</span> <span class="n">time_iter</span> <span class="o">=</span> <span class="n">iter_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
        <span class="n">iter_arr_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)</span>
        <span class="n">iter_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_iter</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">res_recur</span><span class="p">,</span> <span class="n">time_recur</span> <span class="o">=</span> <span class="n">recur_sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
            <span class="n">recur_arr_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_length</span><span class="p">)</span>
            <span class="n">recur_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_recur</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res_recur</span> <span class="o">!=</span> <span class="n">res_iter</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ERROR - {} != {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_recur</span><span class="p">,</span> <span class="n">res_iter</span><span class="p">))</span>
                <span class="k">break</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="c1"># stack limit exceeded</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">iter_arr_lengths</span><span class="p">,</span> <span class="n">iter_times</span><span class="p">,</span> <span class="n">recur_arr_lengths</span><span class="p">,</span> <span class="n">recur_times</span>


<span class="k">def</span> <span class="nf">plot_results</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1005</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Size of input arrays&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Time to calculate sum (ms)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Comparing iterative vs recursive sum methods&#39;</span><span class="p">)</span>

    <span class="n">iter_arr_lengths</span><span class="p">,</span> <span class="n">recur_arr_lengths</span> <span class="o">=</span> <span class="n">xs</span>
    <span class="n">iters</span><span class="p">,</span> <span class="n">recurs</span> <span class="o">=</span> <span class="n">ys</span>
    <span class="n">point_normal</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">point_stack_over</span> <span class="o">=</span> <span class="mi">300</span>

    <span class="c1"># plot iterative times</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iter_arr_lengths</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iters</span><span class="p">),</span>
                <span class="n">s</span><span class="o">=</span><span class="n">point_normal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

    <span class="c1"># plot recursive times</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recur_arr_lengths</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recurs</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">s</span><span class="o">=</span><span class="n">point_normal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="c1"># last point in recursive times is before stack overflow</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recur_arr_lengths</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recurs</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">s</span><span class="o">=</span><span class="n">point_stack_over</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;sum_ints_plot.png&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">1200</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Saved plot as {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
</pre></div>


<h3>Stack depth limits</h3>
<p>The first discovery was the limit to stack depth (it grows downards, contrary to common sense of adding things to the top of the stack). The default value is 1000 in Python 3.4 (use <code>sys.getrecursionlimit()</code> to look it up). Considering that recur_sum_helper is called inside recur_sum, which is wrapped and called inside __main__, we only have 996 stack frames for the recursive sum. </p>
<div class="highlight"><pre><span></span><span class="err">$$$</span> <span class="n">python3</span>
<span class="n">Python</span> <span class="mf">3.4</span><span class="o">.</span><span class="mi">3</span><span class="o">+</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">Oct</span> <span class="mi">14</span> <span class="mi">2015</span><span class="p">,</span> <span class="mi">16</span><span class="p">:</span><span class="mo">03</span><span class="p">:</span><span class="mi">50</span><span class="p">)</span> 
<span class="p">[</span><span class="n">GCC</span> <span class="mf">5.2</span><span class="o">.</span><span class="mi">1</span> <span class="mi">20151010</span><span class="p">]</span> <span class="n">on</span> <span class="n">linux</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
<span class="mi">1000</span>
</pre></div>


<h3>Plots</h3>
<p><img alt="Photo" src="/images/plot_sum_ints_stack_standard.png"></p>
<p>The blue star marks a point of max_stack_depth. Generally, both scatter plots show linear increase in time with a sudden jump in recursive at ~900 </p>
<p><img alt="Photo" src="/images/plot_sum_ints_stack_extra.png"></p>
<p>Using the same sys module, I could setrecursionlimit to a higher than default value and explore the difference between recursive and iterative solution on bigger input arrays. As expected, iterative kept winning and recursive suffered another drastic jump in times (~1600), thought the gradient remained linear.</p>
<h2>Conclusion</h2>
<p>In this post, a simple problem was solved recursively and iteratively. Afterwards, both solutions were benchmarked and analysed in terms of their scalability. </p>
<p>A recursive solution appears to purists and can be more readable in some cases like tree traversal. In this case, the recursive solution suffered. When combined with the lack of TCO and a relatively low default recursion depth limit value in the CPython interpreter, it proved unscalable and less efficient than iterative. Additionally, wrapping a recusive function introduced a bug, which was absent from the iterative solution.</p>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>