<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>mmap vs. ifstream to read a file // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>mmap vs. ifstream to read a file</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/cpp.html">cpp</a>
                                <a class="post-category" href="/tag/linux.html">linux</a>
                        </p>
                </header>
            </section>
            <p>Working on an app that iterates over a huge corpus file line by line made me curious about efficient disk I/O in C++. On each line I need to use the current vector for a calculation that represent words' semantic associations. In this case, the large file is a corpus built from GoogleNews. Each line starts with a word followed by space-separated floats making a 300-dimensional vector finishing with a newline char. The principles should apply for other large files too.</p>
<p>I am examining different ways of efficiently reading a file from disk line-by-line. Each method described below will run on the same file, surrounded by a timer built from <code>std::chrono</code> objects as below.</p>
<p>TODO:</p>
<ul>
<li>Profile improved mmap - solving the 2 caveats: iterate over chars in each mapping, and dealing with leftover data in the last mapping.</li>
<li>Strace analysis</li>
<li>Assembly analysis</li>
</ul>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
  <span class="n">read_file_by_lines</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">diff</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>C++ standard</h2>
<p>The standard C++ way of reading a textfile from disk is by using an input file stream <code>ifstream</code>. Given a path to file and optional arguments, it creates an input filestream associated with the file at the filename. Then using a for-loop, a line of type std::string is created, as we move the input filestream line-by-line.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">read_file_by_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Uses the ifstream from std to open a file given the filename in cur_dir and</span>
<span class="cm">   * read it out line-by-line */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">input</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span> 
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span> <span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">line</span><span class="p">);)</span> <span class="p">{</span> <span class="c1">// uses the \n char in txt file</span>
    <span class="c1">// calculation logic</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>mmap txt file</h2>
<p>The method opens a file descriptor to the filename and starting from the offset of 0, iterates over page_size blocks of memory. </p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">read_mmaped_file_by_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">     mmaps the file into memory by pages (not always aligned with line size).</span>
<span class="cm">  */</span>
  <span class="c1">// find filesize using the stat syscall</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
  <span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">file_size</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">long</span> <span class="n">page_size</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="c1">// linux page size - 4 KB</span>
  <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">O_RDONLY</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="n">file_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">+</span> <span class="n">page_size</span><span class="p">};</span>
    <span class="c1">// do stuff with data</span>
    <span class="n">munmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page_size</span><span class="p">);</span>
    <span class="n">off</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>2 caveats:</p>
<ul>
<li>the inconvinience of operating on raw bytes of data. There is no getline facility for raw bytes, so you need to iterate over each char in the stream and carry over into next mmaping to join split vectors. eg. if pagebreak comes in the middle of a vector like below</li>
</ul>
<p>-0.097343 0.029601 0.058967 0.062243 -0.087515<strong>\n</strong>with -0.015970 0.014091 </p>
<p>the newline will be read as well as the next word and its vector values. To avoid losing data we need to carry a std::vector&lt;300&gt; and push_back values into it. Once all values in it aren't equal to the initialisation value, we can write it out with the word into an unordered_map. getline abstracts this away and looks for "/n" char and strips it out. </p>
<ul>
<li>If the filesize isn't a multiple of pagesize (most of the time it's not), we need a special case to manually mmap the last bits</li>
</ul>
<h2>mmap bin file</h2>
<p>Since mmap doesn't care about newline characters (it's all just bytes), we can implement a mmap that takes a binary file and fix the 2 caveats above. </p>
<h2>Comparison</h2>
<h3>Time</h3>
<p>The memory mapped read takes a second longer than the std method.</p>
<div class="highlight"><pre><span class="nv">$$$$</span> clang++-3.7 -Wall -O3 -std<span class="o">=</span>c++11 std_read_lines.cpp -o std_read_lines
<span class="nv">$$$$</span> ./std_read_lines gnews_corpus.txt 

14.8439 seconds
<span class="nv">$$$$</span> clang++-3.7 -Wall -O3 -std<span class="o">=</span>c++11 mmap_read_lines.cpp -o map_read_lines
<span class="nv">$$$$</span> ./map_read_lines gnews_corpus.txt 

16.5109 seconds
</pre></div>


<h3>Syscalls</h3>
<p>Straced both programmes to compare the kind of syscalls they make to investigate potential bottlenecks.</p>
<h3>Assembly</h3>
<p>Generated assembly using Godbolt's Compiler Explorer. <a href="https://godbolt.org/g/SRsjN1">Link</a>. Need to recompile it first. WIP.</p>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>