<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Comparing different ways to add ints I | Software and puns</title>



<link href="http://petr-tik.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Software and puns" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="http://petr-tik.github.io/">
          <h1 class="title is-4">Software and puns</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/petr-tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/petr_tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">whoami</h2>
        </a></div>
      

      
    </nav>

  </div>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/algorithms">#algorithms</a>



  
  | <a class="subtitle is-6" href="/tags/hackerrank">#hackerrank</a>
  
  | <a class="subtitle is-6" href="/tags/python">#python</a>
  

      
    </div>
    <h2 class="subtitle is-6">June 27, 2017</h2>
    <h1 class="title">Comparing different ways to add ints I</h1>
    
    <div class="content">
      

<h2 id="puzzle">Puzzle</h2>

<p>Given 2 ints represented as array of digits in order (eg. 843 = [8, 4, 3]), implement a function that returns a sum of the 2 ints in the same format.</p>

<p>eg.</p>

<p>[8, 4, 3] + [1, 8, 2] = [1, 0, 2, 5]</p>

<h2 id="idea">Idea</h2>

<p>Implement and profile recursive and iterative solutions to the puzzle above.</p>

<h3 id="recursive-solution">Recursive solution</h3>

<pre><code class="language-python">def recur_sum_helper(arr1, arr2, idx=0, res=[], carry=0):
    if not res:
        res = list() # guarantee it doesn't change array outside func scope
    if idx &gt;= len(arr1) and idx &gt;= len(arr2):
        if carry == 1:
            res.append(1)
        return res
    if idx &gt;= len(arr1):
        carry, item_to_add = divmod(carry + arr2[idx], 10)
        res.append(item_to_add)
        idx += 1
        return recur_sum_helper(arr1, arr2, idx, res, carry)
    if idx &gt;= len(arr2):
        carry, item_to_add = divmod(carry + arr1[idx], 10)
        res.append(item_to_add)
        idx += 1
        return recur_sum_helper(arr1, arr2, idx, res, carry)

    carry, item_to_add = divmod(carry + arr1[idx] + arr2[idx], 10)
    res.append(item_to_add)
    idx += 1
    return recur_sum_helper(arr1, arr2, idx, res, carry)
</code></pre>

<p>Having done some Clojure, functional tools like map and reduce made it feel that a recursive solution was going to be concise. Handling the same edge cases across different array lengths made the implementation more heavily branched and less pretty than expected.</p>

<p>The final return statement will activate once idx exhausts both arrays (i.e. incremented beyond both lengths). If the carry bit has been carried over from the previous stack frame, which called this last stack frame, add 1 to the end of the array and return the result.</p>

<p>Otherwise, if either of the arrays is exhausted, add the ints from the other array keeping carry bit in mind. All 3 cases (arr1 - exhausted, arr2 - not; arr2 - exhaused, arr1 - not; arr1 and arr2 still not exhausted) use divmod function to set the carry bit and item_to_add. On Intel CPUs this should happen in 1 instruction. The only difference is using both arrays if both are still not exhausted.</p>

<h3 id="iterative-solution">Iterative solution</h3>

<p>Unrolls the recursive loop. Instead of creating a stack frame for each digit, add as many digits as possible before one of the arrays runs out, then handle the leftover digits from the longer array. In the case of arrays/numbers of the same length, there won&rsquo;t be any branch misprediction and we will fall through down to the return statement.</p>

<pre><code class="language-python">def iter_sum_helper(arr1, arr2):
    idx = 0
    carry = 0
    res = []
    while idx &lt; min(len(arr1), len(arr2)):
        carry, item_to_add = divmod(carry + arr1[idx] + arr2[idx], 10)
        res.append(item_to_add)
        idx += 1
    if len(arr1) &gt; len(arr2):
        while idx &lt; len(arr1):
            carry, item_to_add = divmod(carry + arr1[idx], 10)
            res.append(item_to_add)
            idx += 1
    else:
        while idx &lt; len(arr2):
            carry, item_to_add = divmod(carry + arr2[idx], 10)
            res.append(item_to_add)
            idx += 1
    if carry == 1:
        res.append(1)
    return res
</code></pre>

<h3 id="wrapper-to-time-each-function-call">Wrapper to time each function call</h3>

<pre><code class="language-python">def timeit(func):
    def newfunc(*args, **kwargs):
        startTime = time.time()
        res = func(*args, **kwargs)
        elapsedTime = time.time() - startTime
        time_as_string = '{:.6f}'.format(elapsedTime * 1000)
        return (res, time_as_string)
    return newfunc
</code></pre>

<p>This takes the wrapped function, passes the original args, times how long it took to execute and returns a tuple of function return value and time_as_string.</p>

<pre><code class="language-python">@timeit
def iter_sum(arr1, arr2):
</code></pre>

<p>For a fair comparison, both should have the same design and stack allocation strategy. Hence both iter_sum and recur_sum methods reverse the incoming arrays and return the result of the helper. The iterative method calculates everything in 1 stack frame. The recursive recur_sum_helper (by definition) creates a stack frame for each call.</p>

<p>As both _sum methods prepare and pass reversed arrays into helper methods, the helper methods return the result array in the opposite order. Both _sum methods reverse the return arrays before returning.</p>

<h4 id="bug">Bug</h4>

<p>In the first version of the recur_sum_helper and wrapper there was a bug - the recursive solution returned an array much longer than expected. This was the wrapper&rsquo;s fault, as was proven by running the methods without wrapping and stepping through it with pdb.</p>

<p>The timeit wrapper method tooks the args and kwargs of the wrappee and kept them across runs. From the second interation onwards, the res array in the wrapped recur_sum_helper was kept inside the wrapper. Python variables are references, so after the res variable was created inside the scope of the wrapper, following <code>res.append</code> calls grew the same res array as before.</p>

<p>Adding</p>

<pre><code class="language-python">def recur_sum_helper(arr1, arr2, idx=0, res=[], carry=0):
    if not res:
        res = list()
</code></pre>

<p>solved the problem by creating a new array.</p>

<h2 id="performance-comparison">Performance comparison</h2>

<p>Using the script below, the wrapper described above, recursive and iterative solutions were benchmarked. The plots below show show time on the y-axis against the size of 2 input arrays on the x-axis. Green points - recursive times, red - iterative, blue star is the stack length of the array at which stack overflows. Catching stack overflow at runtime has to be done with a try/except loop, which breaks on RuntimeError.</p>

<pre><code class="language-python">def try_different_lengths_before_breaks(r_limit, l_limit, py_stack_limit=None):
    if py_stack_limit:
        sys.setrecursionlimit(py_stack_limit)
    iter_arr_lengths = []
    recur_arr_lengths = []
    iter_times = []
    recur_times = []

    for arr_length in range(r_limit, l_limit, 1):
        arr1 = [9 for _ in range(arr_length)]
        arr2 = [1 for _ in range(arr_length)]
        # good test case, because there will be a carry bit over every step
        res_iter, time_iter = iter_sum(arr1, arr2)
        iter_arr_lengths.append(arr_length)
        iter_times.append(time_iter)
        try:
            res_recur, time_recur = recur_sum(arr1, arr2)
            recur_arr_lengths.append(arr_length)
            recur_times.append(time_recur)
            if res_recur != res_iter:
                print(&quot;ERROR - {} != {}&quot;.format(res_recur, res_iter))
                break
        except RuntimeError:
            # stack limit exceeded
            break
    return iter_arr_lengths, iter_times, recur_arr_lengths, recur_times


def plot_results(xs, ys):
    plt.axis([0, 1005, 0, 1.2])
    plt.xlabel('Size of input arrays')
    plt.ylabel('Time to calculate sum (ms)')
    plt.title('Comparing iterative vs recursive sum methods')

    iter_arr_lengths, recur_arr_lengths = xs
    iters, recurs = ys
    point_normal = 5
    point_stack_over = 300

    # plot iterative times
    plt.scatter(np.array(iter_arr_lengths), np.array(iters),
                s=point_normal, color=&quot;red&quot;, marker=&quot;.&quot;)

    # plot recursive times
    plt.scatter(np.array(recur_arr_lengths)[:-1], np.array(recurs)[:-1],
                s=point_normal, color=&quot;green&quot;, marker=&quot;.&quot;)
    # last point in recursive times is before stack overflow
    plt.scatter(np.array(recur_arr_lengths)[-1], np.array(recurs)[-1],
                s=point_stack_over, color=&quot;blue&quot;, marker=&quot;*&quot;)

    fname = &quot;sum_ints_plot.png&quot;
    plt.savefig(fname, dpi=1200)
    print(&quot;Saved plot as {}&quot;.format(fname))
</code></pre>

<h3 id="stack-depth-limits">Stack depth limits</h3>

<p>The first discovery was the limit to stack depth (it grows downards, contrary to common sense of adding things to the top of the stack). The default value is 1000 in Python 3.4 (use <code>sys.getrecursionlimit()</code> to look it up). Considering that recur_sum_helper is called inside recur_sum, which is wrapped and called inside __main__, we only have 996 stack frames for the recursive sum.</p>

<pre><code class="language-python">$$$ python3
Python 3.4.3+ (default, Oct 14 2015, 16:03:50) 
[GCC 5.2.1 20151010] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getrecursionlimit()
1000
</code></pre>

<h3 id="plots">Plots</h3>

<p><img src="{attach}images/plot_sum_ints_stack_standard.png" alt="Photo" /></p>

<p>The blue star marks a point of max_stack_depth. Generally, both scatter plots show linear increase in time with a sudden jump in recursive at ~900</p>

<p><img src="{attach}images/plot_sum_ints_stack_extra.png" alt="Photo" /></p>

<p>Using the same sys module, I could setrecursionlimit to a higher than default value and explore the difference between recursive and iterative solution on bigger input arrays. As expected, iterative kept winning and recursive suffered another drastic jump in times (~1600), thought the gradient remained linear.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, a simple problem was solved recursively and iteratively. Afterwards, both solutions were benchmarked and analysed in terms of their scalability.</p>

<p>A recursive solution appears to purists and can be more readable in some cases like tree traversal. In this case, the recursive solution suffered. When combined with the lack of TCO and a relatively low default recursion depth limit value in the CPython interpreter, it proved unscalable and less efficient than iterative. Additionally, wrapping a recusive function introduced a bug, which was absent from the iterative solution.</p>

      
    </div>
    
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>



</body>
</html>

