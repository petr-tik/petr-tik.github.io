<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Comparing different ways to add ints II | Software and puns</title>



<link href="http://petr-tik.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Software and puns" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="http://petr-tik.github.io/">
          <h1 class="title is-4">Software and puns</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/petr-tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/petr_tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">whoami</h2>
        </a></div>
      

      
    </nav>

  </div>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/python">#python</a>



      
    </div>
    <h2 class="subtitle is-6">July 16, 2017</h2>
    <h1 class="title">Comparing different ways to add ints II</h1>
    
    <div class="content">
      

<h2 id="background">Background</h2>

<p>As outlined in <a href="http://petr-tik.github.io/posts/sum_ints_as_arrays_part_one/">part 1</a>, we are comparing recursive and iterative implementations of long arithmetic of 2 arrays. As seen in the chart at the bottom of the post, there is a sudden jump in execution times of the recursive function, when the length of array becomes ~900 ints. Using the <code>cProfile</code> and <code>line_profile</code> modules in Python, this increase in execution times is investigated in this post. First cProfile was used to record and examine the execution times for <code>recur_sum</code> and <code>iter_sum</code>. After the bottlenecks were located, <code>line_profiler</code> was used to profile each function with higher granularity. To guarantee consistent analysis both implementations will be benchmarked with line profiling enabled.</p>

<h2 id="refactoring">Refactoring</h2>

<p>The script from part 1 had to be changed to profile the relevant function calls and save the results. This effectively wraps the function calls with cProfiler and then saves the results into a .dmp type. Afterwards results are plotted.</p>

<h3 id="plot-results">Plot results</h3>

<p>Instead of using a scatter plot, normal plot was used, which made the increase in gradient more obvious. It also takes the right and left limits to the x values (lengths of the array). Setting xlim to the plot will help us focus the picture. We will not exceed recursion depth in this example. Hence we won&rsquo;t be marking the last point in recursive times.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">plot_results_for_cprofile</span>(xs, ys, r_limit, l_limit):
    plt<span style="color:#666">.</span>xlim(r_limit, l_limit)
    plt<span style="color:#666">.</span>xlabel(<span style="color:#b44">&#39;Size of input arrays&#39;</span>)
    plt<span style="color:#666">.</span>ylabel(<span style="color:#b44">&#39;Time to calculate sum (ms)&#39;</span>)
    plt<span style="color:#666">.</span>title(<span style="color:#b44">&#39;Comparing iterative vs recursive sum methods&#39;</span>)

    iter_arr_lengths, recur_arr_lengths <span style="color:#666">=</span> xs
    iters, recurs <span style="color:#666">=</span> ys

    <span style="color:#080;font-style:italic"># plot iterative times</span>
    plt<span style="color:#666">.</span>plot(np<span style="color:#666">.</span>array(iter_arr_lengths), np<span style="color:#666">.</span>array(iters), c<span style="color:#666">=</span><span style="color:#b44">&#34;red&#34;</span>)

    <span style="color:#080;font-style:italic"># plot recursive times</span>
    plt<span style="color:#666">.</span>plot(np<span style="color:#666">.</span>array(recur_arr_lengths), np<span style="color:#666">.</span>array(recurs), c<span style="color:#666">=</span><span style="color:#b44">&#34;green&#34;</span>)

    fname <span style="color:#666">=</span> <span style="color:#b44">&#34;plot_sum_ints.png&#34;</span>
    plt<span style="color:#666">.</span>savefig(fname, dpi<span style="color:#666">=</span><span style="color:#666">1200</span>)
    <span style="color:#a2f;font-weight:bold">print</span>(<span style="color:#b44">&#34;Saved plot as {}&#34;</span><span style="color:#666">.</span>format(fname))</code></pre></div>
<h3 id="profile-run">Profile run</h3>

<p>Profile run method instantiates 2 <code>cProfile.Profile()</code> classes for iterative and recursive solution profiling. Looping over different array lengths, the <code>iter_sum</code> and <code>recur_sum</code> solutions are profiled. The profiling information is saved to disk using the <code>dump_stats()</code> method, which takes a string for argument name.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">profile_run</span>(r_limit, l_limit):
    <span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">cProfile</span>
    iter_arr_lengths <span style="color:#666">=</span> []
    recur_arr_lengths <span style="color:#666">=</span> []
    iter_times <span style="color:#666">=</span> []
    recur_times <span style="color:#666">=</span> []

    <span style="color:#a2f;font-weight:bold">for</span> arr_length <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">range</span>(r_limit, l_limit, <span style="color:#666">1</span>):
        arr1 <span style="color:#666">=</span> [<span style="color:#666">9</span> <span style="color:#a2f;font-weight:bold">for</span> _ <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">range</span>(arr_length)]
        arr2 <span style="color:#666">=</span> [<span style="color:#666">1</span> <span style="color:#a2f;font-weight:bold">for</span> _ <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">range</span>(arr_length)]

        pr <span style="color:#666">=</span> cProfile<span style="color:#666">.</span>Profile()
        pr2 <span style="color:#666">=</span> cProfile<span style="color:#666">.</span>Profile()

        pr<span style="color:#666">.</span>enable()
        res_iter, time_iter <span style="color:#666">=</span> iter_sum(arr1, arr2)
        pr<span style="color:#666">.</span>disable()
        pr<span style="color:#666">.</span>dump_stats(<span style="color:#b44">&#34;iter_{}&#34;</span><span style="color:#666">.</span>format(<span style="color:#a2f">str</span>(arr_length)))
        iter_arr_lengths<span style="color:#666">.</span>append(arr_length)
        iter_times<span style="color:#666">.</span>append(time_iter)

        pr2<span style="color:#666">.</span>enable()
        res_recur, time_recur <span style="color:#666">=</span> recur_sum(arr1, arr2)
        pr2<span style="color:#666">.</span>disable()
        pr2<span style="color:#666">.</span>dump_stats(<span style="color:#b44">&#34;recur_{}&#34;</span><span style="color:#666">.</span>format(<span style="color:#a2f">str</span>(arr_length)))
        recur_arr_lengths<span style="color:#666">.</span>append(arr_length)
        recur_times<span style="color:#666">.</span>append(time_recur)

    plot_results_for_cprofile([iter_arr_lengths, recur_arr_lengths],
                              [iter_times, recur_times], r_limit, l_limit)</code></pre></div>
<h3 id="dumping-stats">Dumping stats</h3>

<p>Used the length of input arrays as id of this profiler run. Looking at the <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/cProfile.py#L44-L48">source</a> for cProfile.Profile.dump_stats()</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">dump_stats</span>(self, <span style="color:#a2f">file</span>):
        <span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">marshal</span>
        <span style="color:#a2f;font-weight:bold">with</span> <span style="color:#a2f">open</span>(<span style="color:#a2f">file</span>, <span style="color:#b44">&#39;wb&#39;</span>) <span style="color:#a2f;font-weight:bold">as</span> f:
            self<span style="color:#666">.</span>create_stats()
            marshal<span style="color:#666">.</span>dump(self<span style="color:#666">.</span>stats, f)</code></pre></div>
<p>We see that it uses the marshal module. From the <a href="https://docs.python.org/3/library/marshal.html">documentation</a>, we know that:</p>

<blockquote>
<p>Details of the format are undocumented on purpose; it may change between Python versions (although it rarely does).</p>

<p>This is not a general &ldquo;persistence&rdquo; module. For general persistence and transfer of Python objects through RPC calls, see the modules :mod:<code>pickle</code> and :mod:<code>shelve</code>. The :mod:<code>marshal</code> module exists mainly to support reading and writing the &ldquo;pseudo-compiled&rdquo; code for Python modules of :file:<code>.pyc</code> files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you&rsquo;re serializing and de-serializing Python objects, use the :mod:<code>pickle</code> module instead &ndash; the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal.</p>

<p>The :mod:<code>marshal</code> module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.</p>
</blockquote>

<p>What joy! <code>cProfile</code> (the builtin python profiler) uses a badly documented, backwards-incompatible, insecure module with incomplete support for Python types.</p>

<h3 id="line-profiling">Line profiling</h3>

<p>Line profiling was implemented by changing the code for the <code>timeit</code> d