<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>mmap vs. ifstream to read a file | Software and puns</title>



<link href="http://petr-tik.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Software and puns" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="http://petr-tik.github.io/posts/cpp_reading_files/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="http://petr-tik.github.io/">
          <h1 class="title is-4">Software and puns</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/petr-tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/petr_tik'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">whoami</h2>
        </a></div>
      

      
    </nav>

  </div>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/cpp">#cpp</a>



  
  | <a class="subtitle is-6" href="/tags/linux">#linux</a>
  

      
    </div>
    <h2 class="subtitle is-6">May 14, 2017</h2>
    <h1 class="title">mmap vs. ifstream to read a file</h1>
    
    <div class="content">
      <p>Working on an app that iterates over a huge corpus file line by line made me curious about efficient disk I/O in C++. On each line I need to use the current vector for a calculation that represent words&rsquo; semantic associations. In this case, the large file is a corpus built from GoogleNews. Each line starts with a word followed by space-separated floats making a 300-dimensional vector finishing with a newline char. The principles should apply for other large files too.</p>
<p>I am examining different ways of efficiently reading a file from disk line-by-line. Each method described below will run on the same file, surrounded by a timer built from <code>std::chrono</code> objects as below.</p>
<p>TODO:</p>
<ul>
<li>Profile improved mmap - solving the 2 caveats: iterate over chars in each mapping, and dealing with leftover data in the last mapping.</li>
<li>Strace analysis</li>
<li>Assembly analysis</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">main</span>(<span style="color:#0b0;font-weight:bold">int</span> argc, <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>argv[]) {
  <span style="color:#a2f;font-weight:bold">auto</span> start <span style="color:#666">=</span> std<span style="color:#666">::</span>chrono<span style="color:#666">::</span>steady_clock<span style="color:#666">::</span>now();
  read_file_by_lines(argv[<span style="color:#666">1</span>]);
  <span style="color:#a2f;font-weight:bold">auto</span> stop <span style="color:#666">=</span> std<span style="color:#666">::</span>chrono<span style="color:#666">::</span>steady_clock<span style="color:#666">::</span>now();
  std<span style="color:#666">::</span>chrono<span style="color:#666">::</span>duration<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">double</span><span style="color:#666">&gt;</span> diff <span style="color:#666">=</span> stop <span style="color:#666">-</span> start;
  std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span> <span style="color:#666">&lt;&lt;</span> diff.count() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34; seconds</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>;
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
}
</code></pre></div><h2 id="c-standard">C++ standard</h2>
<p>The standard C++ way of reading a textfile from disk is by using an input file stream <code>ifstream</code>. Given a path to file and optional arguments, it creates an input filestream associated with the file at the filename. Then using a for-loop, a line of type std::string is created, as we move the input filestream line-by-line.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">read_file_by_lines</span>(std<span style="color:#666">::</span>string filename) {
  <span style="color:#080;font-style:italic">/* Uses the ifstream from std to open a file given the filename in cur_dir and
</span><span style="color:#080;font-style:italic">   * read it out line-by-line */</span>
  std<span style="color:#666">::</span>ifstream input(filename); 
  <span style="color:#a2f;font-weight:bold">for</span> (std<span style="color:#666">::</span>string line; getline(input, line);) { <span style="color:#080;font-style:italic">// uses the \n char in txt file
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// calculation logic
</span><span style="color:#080;font-style:italic"></span>  }
}
</code></pre></div><h2 id="mmap-txt-file">mmap txt file</h2>
<p>The method opens a file descriptor to the filename and starting from the offset of 0, iterates over page_size blocks of memory.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">read_mmaped_file_by_lines</span>(std<span style="color:#666">::</span>string filename) {
  <span style="color:#080;font-style:italic">/*
</span><span style="color:#080;font-style:italic">     mmaps the file into memory by pages (not always aligned with line size).
</span><span style="color:#080;font-style:italic">  */</span>
  <span style="color:#080;font-style:italic">// find filesize using the stat syscall
</span><span style="color:#080;font-style:italic"></span>  <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">stat</span> st;
  stat(filename.c_str(), <span style="color:#666">&amp;</span>st);
  <span style="color:#a2f;font-weight:bold">const</span> size_t file_size <span style="color:#666">=</span> st.st_size;

  <span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">long</span> page_size <span style="color:#666">=</span> <span style="color:#666">0x1000</span>; <span style="color:#080;font-style:italic">// linux page size - 4 KB
</span><span style="color:#080;font-style:italic"></span>  <span style="color:#0b0;font-weight:bold">long</span> off <span style="color:#666">=</span> <span style="color:#666">0</span>;
  <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#666">*</span>data;
  <span style="color:#0b0;font-weight:bold">int</span> fd <span style="color:#666">=</span> open(filename.c_str(), O_RDONLY);

  <span style="color:#a2f;font-weight:bold">while</span> (off <span style="color:#666">&lt;</span> file_size) {
    data <span style="color:#666">=</span> mmap(<span style="color:#a2f">NULL</span>, page_size, PROT_READ, MAP_PRIVATE, fd, off);
    std<span style="color:#666">::</span>string line <span style="color:#666">=</span> std<span style="color:#666">::</span>string{(<span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>)data, (<span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>)data <span style="color:#666">+</span> page_size};
    <span style="color:#080;font-style:italic">// do stuff with data
</span><span style="color:#080;font-style:italic"></span>    munmap(data, page_size);
    off <span style="color:#666">+=</span> page_size;
  }
}
</code></pre></div><p>2 caveats:</p>
<ul>
<li>the inconvinience of operating on raw bytes of data. There is no getline facility for raw bytes, so you need to iterate over each char in the stream and carry over into next mmaping to join split vectors. eg. if pagebreak comes in the middle of a vector like below</li>
</ul>
<p>-0.097343 0.029601 0.058967 0.062243 -0.087515**\n**with -0.015970 0.014091</p>
<p>the newline will be read as well as the next word and its vector values. To avoid losing data we need to carry a std::vector&lt;300&gt; and push_back values into it. Once all values in it aren&rsquo;t equal to the initialisation value, we can write it out with the word into an unordered_map. getline abstracts this away and looks for &ldquo;/n&rdquo; char and strips it out.</p>
<ul>
<li>If the filesize isn&rsquo;t a multiple of pagesize (most of the time it&rsquo;s not), we need a special case to manually mmap the last bits</li>
</ul>
<h2 id="mmap-bin-file">mmap bin file</h2>
<p>Since mmap doesn&rsquo;t care about newline characters (it&rsquo;s all just bytes), we can implement a mmap that takes a binary file and fix the 2 caveats above.</p>
<h2 id="comparison">Comparison</h2>
<h3 id="time">Time</h3>
<p>The memory mapped read takes a second longer than the std method.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#b8860b">$$$$</span> clang++-3.7 -Wall -O3 -std<span style="color:#666">=</span>c++11 std_read_lines.cpp -o std_read_lines
<span style="color:#b8860b">$$$$</span> ./std_read_lines gnews_corpus.txt 

14.8439 seconds
<span style="color:#b8860b">$$$$</span> clang++-3.7 -Wall -O3 -std<span style="color:#666">=</span>c++11 mmap_read_lines.cpp -o map_read_lines
<span style="color:#b8860b">$$$$</span> ./map_read_lines gnews_corpus.txt 

16.5109 seconds
</code></pre></div><h3 id="syscalls">Syscalls</h3>
<p>Straced both programmes to compare the kind of syscalls they make to investigate potential bottlenecks.</p>
<h3 id="assembly">Assembly</h3>
<p>Generated assembly using Godbolt&rsquo;s Compiler Explorer. <a href="https://godbolt.org/g/SRsjN1">Link</a>. Need to recompile it first. WIP.</p>

      
    </div>
    
  </div>
</section>




<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>



</body>
</html>


