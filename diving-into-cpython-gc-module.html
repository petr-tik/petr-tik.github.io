<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog, ">

        <link rel="alternate"  href="/feeds/all.atom.xml" type="application/atom+xml" title="My blog Full Atom Feed"/>

        <title>Diving into CPython GC module // My blog // </title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background: none repeat scroll 0% 0% #3D4F5D">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">My blog</a></h1>
                            <p class="tagline"></p>
                                <p class="links"><a href="/pages/about">About</a></p>
                                <p class="social">
                                    <a href="https://github.com/petr-tik">
                                        <i class="fa fa-GitHub fa-3x"></i>
                                    </a>
                                    <a href="https://twitter.com/petr_tik">
                                        <i class="fa fa-Twitter fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Diving into CPython GC module</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/python.html">python</a>
                                <a class="post-category" href="/tag/gc.html">gc</a>
                                <a class="post-category" href="/tag/memory.html">memory</a>
                        </p>
                </header>
            </section>
            <p>This is a deep dive into the source code for <code>Modules/gcmodule.c</code> inspired by a previous <a href="/notes-on-pythons-gc.html">blogpost</a>, which outlined the GC mechanism in CPython.</p>
<h1>What is the reason for GC in Python?</h1>
<p>As a managed memory runtime, CPython doesnâ€™t give the programmer direct memory control. This makes it easier to write code without worrying about allocating memory for your variables. Garbage collection is a mechanism for regularly checking that pre-allocated memory is still in use. Being in use means other objects still refer to you for something and your reference count is above 0.</p>
<h1>What kind of GC does Python use?</h1>
<p>Python uses a generation-based ref-counting GC. The number of generations is defined in a macro as 3, where 0th generation keeps track of most recently allocated objects, 2nd generation of long lived objects. Every gc_generation has a threshold (number of objects after which a collection is performed). </p>
<h2>What are the thresholds and why do they have such values?</h2>
<p>The thresholds are initiated at 700, 10 and 10 respectively. This means GC will be kicked off for 0th generation, when we allocate 700 new objects or promote 10 objects to either 1st or 2nd generation. First generation can only have 10 objects (objects that survive collection move to a higher generation). The second generation is the oldest, so objects that survive collection move nowhere and stay in the second generation. The difference between 700 and 10 relies on the heuristic that few objects will survive after 1 generation. This optimises the effect of GC on runtime performance working with newly allocated objects. To improve the performance wrt to long-living objects another heuristic is used to avoid collecting the oldest generation, which can have an unlimited number of objects.</p>
<h1>How is GC invoked?</h1>
<p>Users can directly call gc.collect() to run a full collection. <code>gc.collect</code>, its C equivalent - <code>PyGC_Collect</code> and <code>collect_generations</code> uses <code>collect_with_callback</code>, which uses pre-registered callbacks and executes them before and after the gc has been called. <code>collect_generations</code> finds the oldest generation with more objects than the threshold allows and collects everything up to that generation. That is used, when <code>collect_generations</code> is called. </p>
<h1>collect method</h1>
<p>Below is the main collect method found in <code>Modules/gcmodule.c</code> annotated with my guesses about the use of each variable.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger</span>
<span class="cm">                  generations */</span>
<span class="p">};</span>

<span class="cp">#define NUM_GENERATIONS 3</span>
<span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="cm">/* linked lists of container objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head,                               threshold,      count */</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">700</span><span class="p">,</span>            <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="cm">/* This is the number of objects that survived the last full collection. It</span>
<span class="cm">   approximates the number of long lived objects tracked by the GC.</span>
<span class="cm">   (by &quot;full collection&quot;, we mean a collection of the oldest generation).</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">Py_ssize_t</span> <span class="n">long_lived_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* This is the number of objects that survived all &quot;non-full&quot; collections,</span>
<span class="cm">   and are awaiting to undergo a full collection for the first time.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">Py_ssize_t</span> <span class="n">long_lived_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="n">Py_ssize_t</span>
<span class="nf">collect</span><span class="p">(</span><span class="kt">int</span> <span class="n">generation</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">n_collected</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">n_uncollectable</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">nofail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* # objects collected */</span>
    <span class="n">Py_ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* # unreachable objects that couldn&#39;t be collected */</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">young</span><span class="p">;</span> <span class="cm">/* the generation we are examining */</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span> <span class="cm">/* next older generation */</span>
    <span class="n">PyGC_Head</span> <span class="n">unreachable</span><span class="p">;</span> <span class="cm">/* non-problematic unreachable trash */</span>
    <span class="n">PyGC_Head</span> <span class="n">finalizers</span><span class="p">;</span>  <span class="cm">/* objects with, &amp; reachable from, __del__ */</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span><span class="p">;</span>
    <span class="n">_PyTime_t</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* initialize to prevent a compiler warning */</span>

    <span class="k">struct</span> <span class="n">gc_generation_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">generation_stats</span><span class="p">[</span><span class="n">generation</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_STATS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PySys_WriteStderr</span><span class="p">(</span><span class="s">&quot;gc: collecting generation %d...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">generation</span><span class="p">);</span>
        <span class="n">PySys_WriteStderr</span><span class="p">(</span><span class="s">&quot;gc: objects in each generation:&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_GENERATIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">PySys_FormatStderr</span><span class="p">(</span><span class="s">&quot; %zd&quot;</span><span class="p">,</span>
                              <span class="n">gc_list_size</span><span class="p">(</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">_PyTime_GetMonotonicClock</span><span class="p">();</span>

        <span class="n">PySys_WriteStderr</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyDTrace_GC_START_ENABLED</span><span class="p">())</span>
        <span class="n">PyDTrace_GC_START</span><span class="p">(</span><span class="n">generation</span><span class="p">);</span>

    <span class="cm">/* update collection and allocation counters */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">generation</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">NUM_GENERATIONS</span><span class="p">)</span>
        <span class="n">generations</span><span class="p">[</span><span class="n">generation</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">generation</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* merge younger generations with one we are currently collecting */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">generation</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gc_list_merge</span><span class="p">(</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">generation</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* handy references */</span>
    <span class="n">young</span> <span class="o">=</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">generation</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">&lt;</span> <span class="n">NUM_GENERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">generation</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">young</span><span class="p">;</span>

    <span class="cm">/* Using ob_refcnt and gc_refs, calculate which objects in the</span>
<span class="cm">     * container set are reachable from outside the set (i.e., have a</span>
<span class="cm">     * refcount greater than 0 when all the references within the</span>
<span class="cm">     * set are taken into account).</span>
<span class="cm">     */</span>
    <span class="n">update_refs</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
    <span class="n">subtract_refs</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>

    <span class="cm">/* Leave everything reachable from outside young in young, and move</span>
<span class="cm">     * everything else (in young) to unreachable.</span>
<span class="cm">     * NOTE:  This used to move the reachable objects into a reachable</span>
<span class="cm">     * set instead.  But most things usually turn out to be reachable,</span>
<span class="cm">     * so it&#39;s more efficient to move the unreachable things.</span>
<span class="cm">     */</span>
    <span class="n">gc_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>
    <span class="n">move_unreachable</span><span class="p">(</span><span class="n">young</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>

    <span class="cm">/* Move reachable objects to next generation. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">young</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">long_lived_pending</span> <span class="o">+=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">gc_list_merge</span><span class="p">(</span><span class="n">young</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* We only untrack dicts in full collections, to avoid quadratic</span>
<span class="cm">           dict build-up. See issue #14775. */</span>
        <span class="n">untrack_dicts</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
        <span class="n">long_lived_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">long_lived_total</span> <span class="o">=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* All objects in unreachable are trash, but objects reachable from</span>
<span class="cm">     * legacy finalizers (e.g. tp_del) can&#39;t safely be deleted.</span>
<span class="cm">     */</span>
    <span class="n">gc_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finalizers</span><span class="p">);</span>
    <span class="n">move_legacy_finalizers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">finalizers</span><span class="p">);</span>
    <span class="cm">/* finalizers contains the unreachable objects with a legacy finalizer;</span>
<span class="cm">     * unreachable objects reachable *from* those are also uncollectable,</span>
<span class="cm">     * and we move those into the finalizers list too.</span>
<span class="cm">     */</span>
    <span class="n">move_legacy_finalizer_reachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finalizers</span><span class="p">);</span>

    <span class="cm">/* Collect statistics on collectable objects found and print</span>
<span class="cm">     * debugging information.</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gc</span> <span class="o">=</span> <span class="n">unreachable</span><span class="p">.</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">unreachable</span><span class="p">;</span>
                    <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_COLLECTABLE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">debug_cycle</span><span class="p">(</span><span class="s">&quot;collectable&quot;</span><span class="p">,</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Clear weakrefs and invoke callbacks as necessary. */</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">handle_weakrefs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>

    <span class="cm">/* Call tp_finalize on objects which have one. */</span>
    <span class="n">finalize_garbage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">check_garbage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">revive_garbage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>
        <span class="n">gc_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Call tp_clear on objects in the unreachable set.  This will cause</span>
<span class="cm">         * the reference cycles to be broken.  It may also cause some objects</span>
<span class="cm">         * in finalizers to be freed.</span>
<span class="cm">         */</span>
        <span class="n">delete_garbage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Collect statistics on uncollectable objects found and print</span>
<span class="cm">     * debugging information. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gc</span> <span class="o">=</span> <span class="n">finalizers</span><span class="p">.</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
         <span class="n">gc</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">finalizers</span><span class="p">;</span>
         <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_UNCOLLECTABLE</span><span class="p">)</span>
            <span class="n">debug_cycle</span><span class="p">(</span><span class="s">&quot;uncollectable&quot;</span><span class="p">,</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_STATS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_PyTime_t</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">_PyTime_GetMonotonicClock</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">PySys_WriteStderr</span><span class="p">(</span><span class="s">&quot;gc: done&quot;</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">PySys_FormatStderr</span><span class="p">(</span>
                <span class="s">&quot;gc: done, %zd unreachable, %zd uncollectable&quot;</span><span class="p">,</span>
                <span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">PySys_WriteStderr</span><span class="p">(</span><span class="s">&quot;, %.4fs elapsed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">_PyTime_AsSecondsDouble</span><span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* Append instances in the uncollectable set to a Python</span>
<span class="cm">     * reachable list of garbage.  The programmer has to deal with</span>
<span class="cm">     * this if they insist on creating this type of structure.</span>
<span class="cm">     */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">handle_legacy_finalizers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finalizers</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>

    <span class="cm">/* Clear free list only during the collection of the highest</span>
<span class="cm">     * generation */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear_freelists</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nofail</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyErr_Clear</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gc_str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">gc_str</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;garbage collection&quot;</span><span class="p">);</span>
            <span class="n">PyErr_WriteUnraisable</span><span class="p">(</span><span class="n">gc_str</span><span class="p">);</span>
            <span class="n">Py_FatalError</span><span class="p">(</span><span class="s">&quot;unexpected exception during garbage collection&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Update stats */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n_collected</span><span class="p">)</span>
        <span class="o">*</span><span class="n">n_collected</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n_uncollectable</span><span class="p">)</span>
        <span class="o">*</span><span class="n">n_uncollectable</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">collections</span><span class="o">++</span><span class="p">;</span>
    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">collected</span> <span class="o">+=</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">uncollectable</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyDTrace_GC_DONE_ENABLED</span><span class="p">())</span>
        <span class="n">PyDTrace_GC_DONE</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h1>What kind of objects are tracked?</h1>
<p>Python has a mix of immutable and mutable data structures. Tuples and strings are strictly immutable in python. Every modification of an existing tuple/string, allocates a new object of the same type, applies the transformation in-memory and copies the result into the newly allocated object. Appending a new char to a string, allocates a new string object and sets its values to old_string + new_char. Tuples are different from strings, because they are container objects i.e. they keep track of other objects inside. An immutable container like tuple may contain a mutable object like a list, which needs GC. A completely immutable object - tuple of tuples/integers/strings will neither change as a container nor as its members. Therefore there is no need to GC track it. </p>
<h1>Why and how do you track/untrack objects?</h1>
<p>By default, we still track newly created tuples and leave it to the GC to untrack it. <code>move_unreachable</code> uses <code>_PyTuple_MaybeUntrack</code> (defined in <a href="https://github.com/python/cpython/blob/3.6/Objects/tupleobject.c#L180-L203">Objects/tupleobject.c</a>), which iterates over all the objects in the tuple. If there are no NULL elements (yet to be constructed), it untracks the tuple object i.e. sets its <code>gc_refs</code> to <code>_PyGC_REFS_UNTRACKED</code> and removes its PyGC_Head object from its generation list.</p>
<p>Dictionaries containing only immutable objects like strings also donâ€™t need tracking. Dictionaries are untracked by default, but become tracked as soon as a mutable object is added (using an int as a key). Protip: use strings as keys and tuples as values to avoid invoking GC on your dictionaries.</p>
<h1>How do you prepare a generation for collection?</h1>
<p>To prepare a genertion for collection, we merge all younger generations into the generation that is currently being collected. <code>gc_list_merge</code> appends the younger generation to the list of the currently collected generation.</p>
<h2>gc_list_merge</h2>
<div class="highlight"><pre><span class="cm">/* append list `from` onto list `to`; `from` becomes an empty list */</span><span class="w"></span>
static<span class="w"> </span>void<span class="w"></span>
gc_list_merge<span class="o">(</span>PyGC_Head<span class="w"> </span><span class="o">*</span>from<span class="o">,</span><span class="w"> </span>PyGC_Head<span class="w"> </span><span class="o">*</span><span class="kr">to</span><span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span>PyGC_Head<span class="w"> </span><span class="o">*</span>tail<span class="err">;</span><span class="w"></span>
<span class="w">    </span>assert<span class="o">(</span>from<span class="w"> </span><span class="err">!</span><span class="o">=</span><span class="w"> </span><span class="kr">to</span><span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="err">!</span>gc_list_is_empty<span class="o">(</span>from<span class="o">))</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span>tail<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">to</span><span class="o">-&gt;</span>gc<span class="o">.</span>gc_prev<span class="err">;</span><span class="w"></span>
<span class="w">        </span>tail<span class="o">-&gt;</span>gc<span class="o">.</span>gc_next<span class="w"> </span><span class="o">=</span><span class="w"> </span>from<span class="o">-&gt;</span>gc<span class="o">.</span>gc_next<span class="err">;</span><span class="w"></span>
<span class="w">        </span>tail<span class="o">-&gt;</span>gc<span class="o">.</span>gc_next<span class="o">-&gt;</span>gc<span class="o">.</span>gc_prev<span class="w"> </span><span class="o">=</span><span class="w"> </span>tail<span class="err">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">to</span><span class="o">-&gt;</span>gc<span class="o">.</span>gc_prev<span class="w"> </span><span class="o">=</span><span class="w"> </span>from<span class="o">-&gt;</span>gc<span class="o">.</span>gc_prev<span class="err">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">to</span><span class="o">-&gt;</span>gc<span class="o">.</span>gc_prev<span class="o">-&gt;</span>gc<span class="o">.</span>gc_next<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">to</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="w">    </span>gc_list_init<span class="o">(</span>from<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<p>By creating a variable for <code>tail</code>, we can save the pointer to the last node in the to list. First, we link the second node in the from list with the end of the to list using the <code>tail</code> variable. The second node in the from list becomes the head of the merged list. At the end, we make the head node of the to list point its prev pointer to the last node of the from list and the next pointer of the last node of the from list to the first node of the to list. </p>
<p><code>gc_list_init</code> makes the sentinel node points both pointers to itself. The first node in any gc list is therefore always a sentinel node. </p>
<p>Therefore we merge the <code>from</code> list to the left of the <code>to</code> list. In a full collection, the 0th generation is merged with the 2nd first. The result, where the nodes from the 0th collection are to the left of the nodes from the 2nd collection, is merged with the 1st generation. This results in the following order:</p>
<p>1st generation -&gt; 0th generation -&gt; 2nd generation</p>
<h2>After merging</h2>
<p>Having defined young earlier (currently collected generation) and old (generation right of current) now assign values to them. <code>young</code> acquires the value of the gc_list, which now contains the result of merging all previous generations with the current. <code>old</code> is set to the head of generation to the right, if it exists. eg. when generation = 2, old = young. </p>
<p><code>update_refs</code> and then <code>substract_refs</code> prepares the young generation of collection. At the start of a collection, <code>update_refs()</code> copies the true refcount to gc_refs, for each object in the generation being collected. Whenever another object starts using PyObject op, Py_INCREF is called on this object. Py_INCREF increments the number of total references that have been given out and the objcnt of the given object. <code>update_refs</code> copies refcnt value from PyObjectâ€™s objcnt to gcâ€™s gc_refs field. This field is set to different statuses to signal, if the object is still attached to any other objects. </p>
<p><code>subtract_refs()</code> then adjusts gc_refs so that it equals the number of times an object is referenced directly from outside the generation being collected.</p>
<h2>What happens in a collection?</h2>
<h3>Tentatively move unreachable objects</h3>
<p>After all the objects are merged into the <code>young</code> generation list, another list is initiated to keep track of unreachable objects. <code>move_unreachable</code> walks across the list of young, where objects have had their ob_refcnt and gc_refs updated. Those with refcount &lt;= 0 are moved into unreachable list and its <code>gc_refs</code> is set to <code>GC_TENTATIVELY_UNREACHABLE</code>. Being moved into the unreachable list at this point is no guarantee of being garbage collected, as these objects will be assessed again.</p>
<h3>Promote survived objects to the older generation</h3>
<p>The objects in young that haven't been marked as <code>GC_TENTATIVELY_UNREACHABLE</code> are definitely getting promoted to the next generation by merging <code>young</code> with <code>old</code>.</p>
<h3>Deal with finalizers</h3>
<p>If unreachable objects have finalizers, we need to check if they may be reachable. If so, we can recover them.</p>
<h3>clear weakrefs</h3>
<h4>What are weak references?</h4>
<p>Tidies up all objects in <code>unreachable</code> and guarantees that none of them have weakrefs to other objects.</p>
<h3>check and revive garbage if necessary</h3>
<p><code>finalise_garbage</code> calls objects' custom destructors. <code>check_garbage</code> uses <code>substract_refs</code> to check if the objects in <code>unreachable</code> have references to each other or objects outside. If they turn out to have refs to objects outside of <code>unreachable</code>, <code>revive_garbage</code> sets all objects' <code>gc_refs</code> to GC_REACHABLE and merges the whole list with <code>old</code> generation. </p>
<h3>delete garbage</h3>
<p><code>delete_garbage</code> traverses through the <code>unreachable</code> list and if it has a <code>tp_clear</code> method, invokes it. If the object is still alive after that, its <code>gc_refs</code> is set to GC_REACHABLE and it's moved to the <code>old</code> generation.</p>
<h3>collect stats</h3>
<h3>clear freelists</h3>
<p>If it's a full collection, freelists for different data structures are cleared. More detail below.</p>
<h1>How is a full collection different from collecting generation 0 or generation 1?</h1>
<h2>Runs less frequently using a heuristic</h2>
<p>Collecting all generations (called full collection) including the 2nd every time, would lead to quadratic running time. We can either skip objects or perform fewer collections, so a heuristic is used to run fewer collections. Long-lived objects are those in generation 2. The first 2 generations are bounded by thresholds, whereas generation 2 can grow without a limit. A limit of 25% between objects that are yet to go through a full collection over the number of objects that survived the last collection in generation 2. </p>
<div class="highlight"><pre><span class="k">static</span> <span class="n">Py_ssize_t</span>
<span class="nf">collect_generations</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NUM_GENERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="n">long_lived_pending</span> <span class="o">&lt;</span> <span class="n">long_lived_total</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">collect_with_callback</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></div>


<p>We invoke a full collection if more than 25% of the objects have been allocated since the last full collection.</p>
<h2>Surviving objects don't get promoted</h2>
<p>There is no older generation to get promoted to. When <code>young != old</code>, the objects that are still reachable in the <code>young</code> list are moved to the old. Collecting the oldest generation means we cannot move/promote surviving objects any further.</p>
<div class="highlight"><pre>    else {
        /* We only untrack dicts in full collections, to avoid quadratic
           dict build-up. See issue #14775. */
        untrack_dicts(young);
        long_lived_pending = 0;
        long_lived_total = gc_list_size(young);
    }
</pre></div>


<p>We don't move anything anywhere, just reset <code>long_lived_pending</code> (no object has not survived a full collection) and update <code>long_lived_total</code> with the number of objects. </p>
<h2>Clearing freelists</h2>
<h3>What are freelists?</h3>
<p>Full collection (collecting the oldest generation) involves clearing freelists. Free lists are lists of primitive Python object types allocated during CPython interpreter start. This helps users avoid calling malloc for the first X object creations. Similarly, when an object is collected, it's just returned to the free_list of that PyObject type instead of calling free. Only if your programme uses more objects than originally allocated, will you call malloc. Example from <code>dictobject.c</code> below</p>
<p>The CPython interpreter allocates a list of 80 dictionary objects.</p>
<div class="highlight"><pre><span class="cp">#ifndef PyDict_MAXFREELIST</span>
<span class="cp">#define PyDict_MAXFREELIST 80</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">free_list</span><span class="p">[</span><span class="n">PyDict_MAXFREELIST</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">numfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<h3>Why does CPython preallocate 80 dictionaries?</h3>
<p>The commit adding free_lists and their sizes is an old svn commit with more than a dozen of features in one commit, without explanation or inability to recover the reasoning behind 80.</p>
<h3>How is freelist used to alloc/free dictionaries?</h3>
<p>In the function that creates a new dictionary from given keys and values, first the numfree variable is checked. If all dictionaries in the freelist have been used already (numfree &gt;= 80), we have to allocate our own. Otherwise, Using numfree as index into the array of preallocated data types (eg. dictionaries), we assign mp to a dictionary from the list. Interestingly enough, <code>if (numfree)</code> will also execute the branch, if numfree is negative, which is semantically incorrect, but not impossible.</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">new_dict</span><span class="p">(</span><span class="n">PyDictKeysObject</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">**</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">keys</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="o">--</span><span class="n">numfree</span><span class="p">];</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>If we haven't allocated all dictionaries from the freelist, it means, we can return the current dictionary to the list. Otherwise, it must have been allocated by our programme, not the intepreter at start-up, hence we need to explicitly free it.</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">dict_dealloc</span><span class="p">(</span><span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="n">PyDict_MAXFREELIST</span> <span class="o">&amp;&amp;</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">PyDict_Type</span><span class="p">)</span>
        <span class="n">free_list</span><span class="p">[</span><span class="n">numfree</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
</pre></div>


<h3>How can you clear the list of dictionaries?</h3>
<p>Each of the listed types in their <code>Objects/dictobject.c</code> source files have a method for clearing its freelist. Curiously, the <code>PyDict_ClearList</code> method returns the number of freed objects, but all invocations of the method cast the return type to void, making you wonder, why it returns anything in the first place.</p>
<div class="highlight"><pre><span class="kt">int</span>
<span class="nf">PyDict_ClearFreeList</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">numfree</span> <span class="o">+</span> <span class="n">numfreekeys</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">numfree</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="o">--</span><span class="n">numfree</span><span class="p">];</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">PyDict_CheckExact</span><span class="p">(</span><span class="n">op</span><span class="p">));</span>
        <span class="n">PyObject_GC_Del</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">numfreekeys</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject_FREE</span><span class="p">(</span><span class="n">keys_free_list</span><span class="p">[</span><span class="o">--</span><span class="n">numfreekeys</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Iterates over the freelist, GC_deleting each object in the list. In the end, we have numfree set to 0 and a freelist full of objects ready to be used again.</p>
<h2>What does the collect method return?</h2>
<p>The method signature. Returns a static signed size_t int. Input is generation (between 0 and 2 - higher is older), pointer to a variable tracking the <code>n\_collected</code> objects so far, <code>uncollectable</code> and <code>nofail</code> variable. Looking ahead <code>nofail</code> is only used once to decide if an error message should be printed to terminal. Both Py_ssize_t objects - <code>n\_collected</code> and <code>n\_uncollectable</code> - will be updated in-place (at their addresses) with m and n respectively.</p>
<div class="highlight"><pre>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* # objects collected */</span>
    <span class="n">Py_ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* # unreachable objects that couldn&#39;t be collected */</span>
</pre></div>


<h2>Why are variables like m and n used?</h2>
<p>I guess programmers in the 90s were paid inversely proportionally to the number of chars they typed. That would explain <code>mkdir</code>, <code>creat</code>, <code>m</code>, <code>n</code>. </p>
<p>Stack allocating the vars we will need to collect this generation with. No other choice - heap allocating variables used in GC is just rude. </p>
<h1>What is PyGC_Head and how is it related to PyObject?</h1>
<h3>PyGC_Head</h3>
<p>Most variables are of type PyGC_Head, whose definition is in <a href="https://github.com/python/cpython/tree/3.6/Include/objimpl.h#L251-L259">objimpl.h</a></p>
<div class="highlight"><pre><span class="cm">/* GC information is stored BEFORE the object structure. */</span>
<span class="cp">#ifndef Py_LIMITED_API</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</pre></div>


<p>The meaty part of the type is pointers of the same type to next and previous <code>_gc_head</code> types and the <code>gc_refs</code> that keeps track of the number of references.</p>
<h3>Why double dummy?</h3>
<p>Paraphrasing the commit message - the <code>double dummy</code> is to make sure 8-byte alignment won't break. When 8-byte alignment is required, padding is added, otherwise, there won't be any change.</p>
<h3>Why recursively defined gc struct?</h3>
<p>This uses a sentinel doubly linked list. An empty linked list contains one node, whose <code>.gc_prev</code> and <code>.gc_next</code> link to the node itself. Appending nodes to the end of a list means linking the <code>.gc_next</code> and <code>.gc_prev</code> of the new_node to the head of the list and last element of the list respectively. The first element is a dummy - sentinel - node.  That's why all list traversal operations begin initiate <code>gc = list-&gt;gc.gc_next</code> as below</p>
<div class="highlight"><pre><span class="k">static</span> <span class="n">Py_ssize_t</span>
<span class="nf">gc_list_size</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gc</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">list</span><span class="p">;</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">++</span><span class="p">;</span>
</pre></div>


<p>and to check emptiness you need to compare pointers between the head and the first next element after the sentinel. </p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">gc_list_is_empty</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">==</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>PyObject</h2>
<p>The PyObject struct is defined in <a href="https://github.com/python/cpython/3.6/blob/Include/object.h">Include/object.h</a>. Contains the reference count and type of the object.</p>
<div class="highlight"><pre><span class="cm">/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
<span class="cp">#define _PyObject_HEAD_EXTRA            \</span>
<span class="cp">    struct _object *_ob_next;           \</span>
<span class="cp">    struct _object *_ob_prev;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">_PyObject_HEAD_EXTRA</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</pre></div>


<h2>PyObject to/from PyGC_Head</h2>
<div class="highlight"><pre><span class="cm">/* Get an object&#39;s GC head */</span>
<span class="cp">#define AS_GC(o) ((PyGC_Head *)(o)-1)</span>

<span class="cm">/* Get the object given the GC head */</span>
<span class="cp">#define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))</span>
</pre></div>


<h3>Collecting</h3>
<p><code>gc_refs</code> values determine if an object should be collected. When an object is mallocâ€™ed, its <code>gc_refs</code> is set to <code>GC_UNTRACKED</code>, because itâ€™s absent from any generation list. </p>
<p>As soon as itâ€™s added to a generation list its <code>gc_refs</code> is updated to GC_REACHABLE.</p>
<p>When collecting happens, <code>gc_refs</code> may take other values. The most important is GC_TENTATIVELY_UNREACHABLE, which means the object has been moved to the unreachable set. Even when ref updating is over and an object is GC_TENTATIVELY_UNREACHABLE, it may be made reachable again, because it has a <code>__del__</code> method. This is done with a revive_garbage method, which takes a pointer to list of supposedly unreachable objects, which turned out to have refs to objects outside their own group.</p>
<h2>Summary</h2>
<p>This blog is a read-through of the <code>Modules/gcmodule.c</code> of the CPython interpreter. The logic is inside the <code>collect</code> method, which is called by <code>collect_with_callback</code>. The <code>gc</code> module exposes the <code>gc.collect()</code> method that users can manually activate in terminal, which performs a full collection. Some heuristics and tips to use CPython efficiently were explained and internals of object allocation/collection were outlined. </p>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Petr Tikilyaynen &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>